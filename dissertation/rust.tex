\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{The Rust Programming Language}
\label{ch:rust}

This work refers to version 1.35 of the Rust
compiler.\footnote{Specifically, the nightly build dated March 22, 2019,
commit \texttt{2210e9a}. \\ Accessible at
\url{https://github.com/rust-lang/rust/commit/2210e9a6a99c4241d82e85ca71fd291d5ef91c7f}.
\\ Patches for CHERI compatibility at \url{https://github.com/CTSRD-CHERI/rust/}.}


\section{Overview}
This chapter gives an overview of Rust and the major differences from
comparable programming languages.
It focusses on semantic differences, rather than usability differences,
although those also make a significant contribution to code
safety.\footnote{Usability differences include the lack of automatic
typecasting, the explicit use of integer widths (e.g.\ \texttt{i32}
rather than \texttt{int}, and \texttt{usize} for array indices), and the
built-in test harness.}

For any future effort in porting Rust to CHERI, attention \emph{must} be
paid to pointer width and indices (\Cref{sec:rust-usize}).
\emph{Currently, this effectively prevents Rust code from compiling
properly for CHERI.}

\wip{What else?}


\section{The Rust programming language}
Rust is billed as a fast and safe systems programming language.
It uses both compile-time and runtime checks to prevent overflows,
widely employing fat pointers for built-in data
structures~\cite{blandy-orendorff}.
For example, the built-in Vector (\texttt{Vec}) stores data on its
allocated capacity and actual length; a CHERI capability pointer to the
same vector would also track the allocated capacity as a boundary.
This suggests there may be some room for optimisation.

\wip{Probably a lot more to say}

\clar{Helpful to delineate ``differences'' and ``implications''?}


\subsection{Object ownership and move semantics}
\label{sec:rust-borrow}

\clar{So what?}

One of the guarantees Rust offers is that Safe Rust should never lead to
dangling pointers or memory leaks.
Yet it does not have a garbage collector, or expose memory management.
Instead, the compiler couples strict ownership analysis with borrow and
move semantics to determine the lifetime of an object.
As such, some programs which avoid use-after-free or other memory safety
bugs may be semantically invalid Rust.

\begin{figure}[ht]
\begin{lstlisting}
// Lifetime ends; `v` becomes uninitialised in caller.
fn take_ownership(v: Vec<i32>)

// Caller receives a vector, which may be distinct from the original.
fn take_and_return(v: Vec<i32>) -> Vec<i32>

// `borrow` receives a reference to `v` which it cannot mutate.
// `v` is defined for the caller afterward; it should be unchanged.
fn borrow(v: &Vec<i32>)

// `borrow_mutably` receives a mutable reference to `v`.
// `v` is defined for the caller afterward; it may be changed.
fn borrow_mutably(v: &mut Vec<i32>)
\end{lstlisting}
\caption{\wip{Example could be better} Function signatures for passing a
\texttt{Vec}, \texttt{v} to a function. To prevent data races, only one
code block can have a mutable reference to a variable at a time.}
\label{lst:rust-ownership}
\end{figure}

Instead of pointers, a function in Safe Rust will either take ownership
of an object, or borrow it either immutably or mutably.
\Cref{lst:rust-ownership} shows some function signatures for
moving ownership or borrowing.
In contrast to C, the emphasis is not on access, but the nature of the
access.\footnote{In Rust, references represent possession of an object,
rather than the ability to access it.}
As such, pointers cannot be casually duplicated\footnote{In Safe Rust.}
to cause data races or temporal unsoundness generally \wip{remove?}.

Ownership does not guarantee spatial safety on its own.
However, it makes ownership explicit and \wip{provenance? clear}.
\wip{More}

\wip{Unclear?}
An exception to the memory leak guarantee is the exposure of
\texttt{mem::forget} in the core library as a safe function.
This allows an object's lifetime to end without deallocating it,
avoiding double-frees in circular data structures.
This can create a leak, as can a knot-tied reference-counted data
structure, though knot-tying is made difficult in light of the single
mutable reference rule.


\subsection{Optimisation by eliding checks}
\label{sec:rust-elision}

\wip{para too long}
For spatial safety, Rust also implements runtime bounds checks to
prevent out-of-bounds accesses.
This may appear to harbour large overheads, although with optimisations
many checks are elided.
\Cref{sec:eval-rust-bounds} shows \wip{(soon)} an example of bounds
check elision in generated code.

Some common situations in which bounds checks are avoided \wip{more}:

\begin{description}
    \item[Built-in binary search] Checks avoided without unsafe code by
    providing more information to compiler: uses slices instead of
    indices~\cite{rust-pr-binarysearch}.
    \item[Built-in slice equality] Similar to \textbf{binary search},
    providing more information to the compiler makes a different
    iteration strategy faster without unsafe dereferencing~\cite{rust-pr-slice-partialeq}.
    \item[Built-in iterators] The default iterator, applying to arrays,
    uses the unsafe \texttt{get\_unchecked} method\footnote{This adds an
    offset to the array's base pointer and dereferences it directly.
    Other \texttt{unchecked} methods exist, e.g.\ in string
    conversions.} implemented for the \texttt{SliceIndex} trait.
    In theory, this \emph{might} be susceptible to an off-by-one error,
    but is easily tested.
    \item[Image processing] Dr\"oge demonstrates different strategies to
    optimise Rust code without unsafe code, avoiding bounds checks and
    other unnecessary operations~\cite{droge-opt}.
    This is achieved through strategic assertions and optimal use of
    iterators and other built-ins.
    Note that similar optimisation through assertions may be fragile or
    made obsolete through updated code generation, and that optimal use
    of built-ins may require knowledge of the underlying (unsafe)
    implementations.
\end{description}

\wip{rewrite}
Further, these only apply for random indexing.
This avoids redundant checks, whether they are duplicated or simply
known to be within bounds.
Naturally, there is scope for programmer error here:
\Cref{sec:eval-micro-push} discusses an off-by-one error in
the standard library.

Finally, there is an experimental effort~\cite{rust-crate-indexing} to
remove array bounds checks using dependent types, using the principles
described by Xi and Pfenning~\cite{xi-pfenning-dependent} and applied to
Rust by Beingessner~\cite{beingessner}.
It should be noted that this could add a significant compile-time
overhead, as it necessarily utilises type-, lifetime, and ownership
checkers, which Rust runs before optimisations: this results in
heavy computation to remove checks that are usually avoided anyway.


\subsection{Unsafe Rust}
\label{sec:rust-unsafe}

Another area of optimisation is the use of \emph{Unsafe} Rust, which
permits several additional actions~\cite{rust-unsafe-powers}:

\begin{itemize}
    \item Dereferencing a raw pointer
    \item Calling unsafe functions
    \item Accessing or modifying a mutable static variable
    \item Implementing an unsafe trait
\end{itemize}

While these seem fairly innocuous (considering the large body of
existing C code), this is significant in the restrictions imposed on
safe Rust.
It's important to note that unsafety need not necessarily come from
the \texttt{unsafe} code block itself, but from the handling of inputs
and outputs to the unsafe block.
\Cref{sec:eval-micro-repeat} shows a bug in a built-in data structure
caused by incorrect computation before an \texttt{unsafe} block, leading
to a buffer overflow.

As discussed in \Cref{sec:rust-elision}, unsafe optimisations in
the Rust compiler may take the form of unchecked accesses or conversions
known to be safe.
Another example would be to override the default allocation strategy
when initialising a vector with data: there is no need to fill the
allocated space with zeroes or poison values if it is guaranteed to be
overwritten before access.


\subsection{Definitions of pointers and indices}
\label{sec:rust-usize}

\subsubsection{Differences}
In Rust, a \texttt{usize} is defined to be a pointer-sized integer,
conventionally equivalent to C's \texttt{uintptr\_t}, which \emph{may
not be equivalent to \texttt{size\_t}}~\cite{rust-rfc-isize}.
The width of a \texttt{usize} derives from the data layout's pointer
width, 128 bits for a CHERI capability.
Crucially, \texttt{usize} is used as the index size in Rust, for
indexing into arrays, structs, and all objects, and is hence passed to
LLVM instructions such as \texttt{getelementptr}.

\subsubsection{Implications and changes}
Having a 128-bit \texttt{usize} meant that the Rust compiler would
instruct LLVM to generate 128-bit indexed versions of intrinsics such as
\texttt{memcpy}, in addition to indexing.
However, not all bit widths for the \texttt{memcpy} intrinsic are
supported by all targets~\cite{llvm-langref}, and CHERI supports a bit
width of 64 but not 128.

I consider this an implementation detail, as we can index these
intrinsics by sizes other than \texttt{usize}.
However, changing the Rust compiler to recognise different index sizes
from the pointer width is a non-trivial change; my attempts to do so
resulted in a non-functional compiler.

A straightforward workaround is to truncate the index (\texttt{len})
variable to 64 bits before every such operation.
This is problematic for two reasons.
First, such a change is prone to leaving out some intrinsics which may
silently fail, leaving the process open to functional errors.
Second, use of 128-bit integers is slow on CHERI, and unnecessary
casting also generates unnecessary instructions.
To target CHERI properly, Rust \emph{must} support pointer widths larger
than the index size.

\end{document}
