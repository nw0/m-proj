\documentclass[dissertation.tex]{subfile}

\chapter{The Rust Programming Language}
\label{ch:rust}

This work refers to version 1.35 of the Rust
compiler.\footnote{Specifically, the nightly build dated March 22, 2019,
commit \texttt{2210e9a}. \\ Accessible at
\url{https://github.com/rust-lang/rust/commit/2210e9a6a99c4241d82e85ca71fd291d5ef91c7f}.
\\ Patches for CHERI compatibility at \url{https://github.com/CTSRD-CHERI/rust/}.}


\section{Overview}
This chapter gives an overview of Rust and the major differences from
comparable programming languages.
It focusses on semantic differences, rather than usability differences,
although those also make a significant contribution to code
safety.\footnote{Usability differences include the lack of automatic
typecasting, the explicit use of integer widths (e.g.~\texttt{i32}
rather than \texttt{int}, and \texttt{usize} for array indices), and the
built-in test harness.}

For any future effort in porting Rust to CHERI, attention \emph{must} be
paid to pointer width and indices (Section~\ref{sec:rust-usize}).
\emph{Currently, this effectively prevents Rust code from compiling
properly for CHERI.}

\wip{What else?}


\section{The Rust programming language}
Rust is billed as a fast and safe systems programming language.
It uses both compile-time and runtime checks to prevent overflows,
widely employing fat pointers for built-in data
structures~\cite{blandy-orendorff}.
For example, the built-in Vector (\texttt{Vec}) stores data on its
allocated capacity and actual length; a CHERI capability pointer to the
same vector would also track the allocated capacity as a boundary.
This suggests there may be some room for optimisation.

\wip{Probably a lot more to say}

\subsection{Optimisation opportunity}

\clar{Move to evaluation?}

With checks preventing out-of-bounds accesses, for instance, Rust might
initially appear to harbour large overheads.
Indeed, for code compiled in \emph{debug mode with assertions}, all
checks are performed, from checks on bounds to those on integer
overflows.
However, with optimisations enabled, many of these checks are elided:
for instance, array sizes are fixed at compile time, and most accesses
take the form of iteration, making a check redundant.
In this way, a number of checks are removed either by the Rust compiler
or LLVM.

\subsection{Unsafe Rust}
\label{sec:rust-unsafe}

\wip{Unsafety isn't unusual, many langs have escape hatches...}

Another area of optimisation is the use of \emph{Unsafe} Rust, which
permits several additional actions~\cite{rust-unsafe-powers}:

\begin{itemize}
    \item Dereferencing a raw pointer
    \item Calling unsafe functions
    \item Accessing or modifying a mutable static variable
    \item Implementing an unsafe trait
\end{itemize}

While these seem fairly innocuous (considering the large body of
existing C code), this is significant in the restrictions imposed on
safe Rust.
It's important to note that unsafety need not necessarily come from
the \texttt{unsafe} code block itself, but from the handling of inputs
and outputs to the unsafe block.

Many unsafe optimisations in the Rust compiler take the form of
unchecked accesses: the suppression of unneeded or repeated checks, such
as slice accesses into objects of known size and layout.
Another example is arbitrarily indexing into a (Unicode) string, where
the chosen index is known to be a character boundary.


\subsection{Move semantics and borrowing}
\label{sec:rust-borrow}

One of the guarantees Rust offers is that Safe Rust should never lead to
dangling pointers or memory leaks.
In contrast to other languages, it achieves this without a garbage
collector.
Instead, the compiler uses borrow and move semantics to determine object
lifetimes and ownership, preventing misuse of references.

\wip{This isn't strictly true? Knot-tying, Rc.}


\subsection{Definitions of pointers and indices}
\label{sec:rust-usize}

\wip{post-move rewrite}

\subsubsection{Differences}
In Rust, a \texttt{usize} is defined to be a pointer-sized integer,
conventionally equivalent to C's \texttt{uintptr\_t}, which \emph{may
not be equivalent to \texttt{size\_t}}~\cite{rust-rfc-isize}.
The width of a \texttt{usize} is derived from the data layout's pointer
width, which is 128 bits for a CHERI capability.
Crucially, \texttt{usize} is used as the index size in Rust, for
indexing into arrays, structs, and all objects, and is hence passed to
LLVM instructions such as \texttt{getelementptr}.

\subsubsection{Implications and changes}
Having a 128-bit \texttt{usize} meant that the Rust compiler would
instruct LLVM to generate 128-bit indexed versions of intrinsics such as
\texttt{memcpy}, in addition to indexing.
However, not all bit widths for the \texttt{memcpy} intrinsic are
supported by all targets~\cite{llvm-langref}, and CHERI supports a bit
width of 64 but not 128.

This is a straightforward change, by truncating the index (\texttt{len})
variable to 64 bits before every such operation.
This is problematic for two reasons.
First, such a change is prone to leaving out some intrinsics which may
silently fail, leaving the process open to functional errors.
Second, use of 128-bit integers is slow on CHERI, and unnecessary
casting also generates unnecessary instructions.
To target CHERI properly, Rust \emph{must} support pointer widths larger
than the index size.
