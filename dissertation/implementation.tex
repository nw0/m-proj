\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}


\section{Overview}

\todo{Rewrite, sectional overview?}
This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.
It details the strategy taken, defining the scope of the project, and
the differences of Rust to other languages which influence any effort to
port Rust to CHERI.

\todo{Distinguish compiler changes and libcore changes. Mention libcore
changes explicitly: e.g. memchr---there are only about 5 of these.}

\section{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM as a backend for compilation.
The CTSRD project maintains a fork of LLVM with support for the
current CHERI implementation, which extends the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.

\subsection{Incompatibilities with the LLVM backend}
Due to the pointer width and index size divergence
(\Cref{sec:rust-usize}), two incompatibilities were found with the CHERI
LLVM backend.
These have been fixed in the current version.

\begin{itemize}
    \item Rust may attempt to generate an unusual pointer offset when
    calling or returning from functions.\footnote{Fix at \url{https://github.com/CTSRD-CHERI/llvm-project/commit/39cfdf711a759a4799bd32f50af07f5f6f43c987}.}
    \item Rust sometimes attempts to generate unaligned loads.
    This is not possible in the pure capability ABI.\footnote{Fix at \url{https://github.com/CTSRD-CHERI/llvm-project/commit/d8e6acf3d4094270cd55b70341a6f9c4d032db81}.}
\end{itemize}

\section{Strategy}
\label{sec:impl-what}

\subsection{Host platform}
One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This is achieved by cross-compilation from an amd64 FreeBSD host; other
host platforms should work if they are able to compile the CHERI SDK.

\subsection{Rust functionality on CHERI}
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.
This avoids the hurdle of dealing with multiple LLVM address spaces and
pointer widths, not supported in the Rust compiler
(\Cref{sec:impl-addrspace}).

In order to evaluate Rust on CHERI, I identified
a minimal necessary subset of the standard library, listed below.
Not included is the bulk of the Rust standard library, which provides
filesystem and network support, general IO, interfaces to operating
system synchronisation and threading, and others.
I consider these not to have critical significance to capabilities in
standalone Rust programs.

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    It also includes support for calling to foreign function interfaces
    (FFI), unicode and number formatting, etc.
    It could be thought of as a modern version of the standard C
    headers, apart from the core definitions it provides, which would be
    built into a compiler.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, demonstrated in the evaluation
    (\Cref{sec:eval-micro-push,sec:eval-micro-repeat}).
\end{description}

Other parts of the standard library will compile for CHERI, but they are
not as central to running Rust programs.
I have not included them here in order to focus on evaluating the Rust
compiler and a core set of features.

\Cref{sec:impl-divergences} details modifications to the compiler and
these libraries required to compile Rust programs.

\subsection{Compiler optimisations}
Finally, optimisations are \emph{not} used.
Optimisations are not supported at this point as they cause the Rust
compiler to invoke LLVM APIs with values not supported by the CHERI
backend, such as offsets of 128 bits.
\Cref{sec:impl-width} discusses this briefly.


\section{Differences arising from the CHERI target}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
This section documents these differences, their implications, and the
modifications required to compile Rust for CHERI.


\subsection{Pointer width of 128 bits}
\label{sec:impl-width}

\subsubsection{Differences}
Under pure capability mode in CHERI128, all pointers are 128-bit wide
capabilities.
The Rust compiler has built-in support for 16-, 32-, and 64-bit
pointers, through compile-time macros.
The pointer width is used to determine the \texttt{usize}\footnote{The
maximum index size.} (\Cref{sec:rust-usize}), offsets, and sizes used
for pointer operations.

\subsubsection{Choices and implications}
The 128-bit pointer width cannot be changed.

The Rust compiler has two definitions of the target's pointer width: the
\texttt{target\_pointer\_width value} in the target specification
(\Cref{sec:impl-cheritarget}), and the LLVM data layout string.
These values \emph{must} agree to avoid alignment issues.

In any case, the value derived from data layout string is used in more
than 50 locations in the compiler, to determine the index size and
pointer alignment, and for code generation among others.
This includes which index size to use when calling LLVM intrinsics, such
as \texttt{memset}, and what size integer to provide for an
\texttt{inttoptr} call; CHERI only supports 64-bit integers for all
these cases.

The immediately obvious solution is to support a 64-bit index size, but
this is met with a non-functional compiler.
As \Cref{sec:rust-usize} noted, the Rust language defines the
\texttt{usize} to be equal to the pointer width, and this assumption is
sufficiently widespread in the compiler to make it impractical to change
within the scope of this project.
However, if this definition is changed, or the definitions of
\texttt{usize} can be distinguished from the usage of index sizes for
code generation, then the changes in the next section may not be
necessary.


\subsubsection{Changes and limitations}
This meant defining a \texttt{usize}, and exposing a 128-bit integer
type from LLVM as suitable for this value.
This is not a functional problem: while 128-bit integer usage is not
natively supported on CHERI, it is merely slower and LLVM will generate
the correct instructions.

The other change is to truncate or extend integer types before calls to
LLVM intrinsics and pointer operations.
An example of the former is \texttt{memcpy}: if indexed by a 128-bit
length, LLVM silently omits the copy, as it is not defined in the
CHERI backend.
This change is problematic, as it is possible to miss out the truncation
or extension for some intrinsics, then be unaware that the compiler has
omitted them.
Pointer operations are more limited: we need only concern ourselves with
\texttt{inttoptr} and \texttt{ptrtoint}.
Here, we take performance penalties from generating excess instructions
and 128-bit integer operations.


\subsection{Address spaces}
\label{sec:impl-addrspace}

\subsubsection{Differences}
CHERI uses LLVM address space 200 for capabilities, and 0 for
non-capability pointers.
Supporting pure capability mode only requires use of address space 200.

By contrast, Rust currently only generates code that uses address space
0, the default address space in LLVM.
There is also no support to use multiple address spaces within or across
compilation units.

\subsubsection{Choices and implications}
With pure capability mode, only one address space is required, thus the
latter problem is avoided.
In any case, there is no requirement to support legacy code and pointer
manipulation idioms in the scope of this work, thus little reason to
support hybrid mode, which allows the use of untagged pointers.

\subsubsection{Changes and limitations}
The main change was to make Rust aware of LLVM address spaces other than
0; it already specified this as the default.
Previous work to support the AVR platform on Rust already (in principle)
supported address space 1 for functions, so the changes required were to
determine the pointer width correctly from the LLVM data layout string,
and to ensure allocations were made to the correct address space, again
using the data layout string.

Based on the Rust codebase, it could be difficult but far from
impossible to support multiple address spaces in Rust.
A far bigger challenge, however, is to support code generation for
multiple pointer widths: it will therefore be impractical to consider
compiling Rust programs in hybrid mode unless this changes.


\subsection{Targeting CHERI}
\label{sec:impl-cheritarget}

\subsubsection{Differences}
CHERI is an extension to the big-endian 64-bit MIPS architecture.
A target specification was added to the Rust compiler, specifying the
pure-capability ABI, and the CPU.

\subsubsection{Changes required}
Modify Rust compiler to pass on target information such as
\texttt{purecap} ABI and use the \texttt{cheri128} CPU.


\section{Other challenges and incompatibilities}
\clar{Correct section to talk about 64-bit conversion?}

\end{document}
