\documentclass[dissertation.tex]{subfile}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}

\wip{Problems, details}
Optimisations not possible, \texttt{no\_std}.


\section{Overview}
\wip{What is this chapter for?}

This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.

\wip{Sectional overview might be useful}

\subsection{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM a backend for compilation.
The CTSRD project also develop a fork of LLVM with support for the
current CHERI implementation, with changes to the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.


\section{Strategy}
\label{sec:impl-what}

One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.

In order to evaluate \wip{(evaluate what?)} Rust on CHERI, I identified
a minimal necessary subset of the standard library:

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, used in the evaluation (Section~\wip{x}).
\end{description}

The rest of the standard library includes \wip{helpful things e.g. IO},
where capabilities are not immediately relevant.
\wip{So?}

Some modification of these libraries was needed for them to work, as
Section~\ref{sec:impl-divergences} details. \wip{So?}


\section{Differences arising from the CHERI target}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
This section documents these differences, their implications, and the
modifications required to compile Rust for CHERI.

\wip{remove list}
\begin{itemize}
    \item The inability to arbitrarily manipulate pointers through
    unsafe code. In particular, certain routines in the standard library
    will not compile.
    \item The impossibility of indexing by pointer-width sized integers,
    or using these in operations such as \texttt{ptrtoint}.
    This is entirely consistent with LLVM, but the Rust compiler assumes
    otherwise.
\end{itemize}


\subsection{Pointer width of 128 bits}
\label{sec:impl-width}

\subsubsection{Differences}
Under pure capability mode in CHERI128, all pointers are 128-bit wide
capabilities.
The Rust compiler has built-in support for 16-, 32-, and 64-bit
pointers, through compile-time macros; these are primarily used to
determine the \texttt{usize} (Section~\ref{sec:impl-usize}).

\subsubsection{Implications and changes}
This meant defining a \texttt{usize}, and exposing a 128-bit integer
type from LLVM as suitable for this value.
As Section~\ref{sec:impl-usize} shows, it was not possible to use a
64-bit \texttt{usize}, with its own implications.


\subsection{Definitions of pointers and indices}
\label{sec:impl-usize}

\subsubsection{Differences}
In Rust, a \texttt{usize} is defined to be a pointer-sized integer,
conventionally equivalent to C's \texttt{uintptr\_t}, which \emph{may
not be equivalent to \texttt{size\_t}}~\cite{rust-rfc-isize}.
The width of a \texttt{usize} is derived from the data layout's pointer
width, which is 128 bits for a CHERI capability.
Crucially, \texttt{usize} is used as the index size in Rust, for
indexing into arrays, structs, and all objects, and is hence passed to
LLVM instructions such as \texttt{getelementptr}.

\subsubsection{Implications and changes}
Having a 128-bit \texttt{usize} meant that the Rust compiler would
instruct LLVM to generate 128-bit indexed versions of intrinsics such as
\texttt{memcpy}, in addition to indexing.
However, not all bit widths for the \texttt{memcpy} intrinsic are
supported by all targets~\cite{llvm-langref}, and CHERI supports a bit
width of 64 but not 128.

This is a straightforward change, by truncating the index (\texttt{len})
variable to 64 bits before every such operation.
This is problematic for two reasons.
First, such a change is prone to leaving out some intrinsics which may
silently fail, leaving the process open to functional errors.
Second, use of 128-bit integers is slow on CHERI, and unnecessary
casting also generates unnecessary instructions.
To target CHERI properly, Rust \emph{must} support pointer widths larger
than the index size.


\wip{128 not supported because of const\_eval}

\wip{purecap abi, chericap, etc.}

\wip{memset.i128}

\wip{ptrtoint, intcasts}

\subsection{Address spaces}

\subsubsection{Differences}
There is no support in the Rust compiler to use LLVM address spaces
other than 0, the default.
By implication, there is also no support for multiple address spaces
within or across compilation units.

\subsubsection{Changes required}
As only one address space is recognised, I decided to use pure
capability mode, in which all pointers are capabilities, rather than
hybrid mode, which accepts untagged pointers as well.
Minor changes were made to refer to Rust's
\texttt{instruction\_address\_space} for all pointers, instead of only
pointers to types.

\subsection{Manipulation of pointers}
\label{sec:impl-manipulation}

\subsubsection{Differences}

\wip{e.g.~memchr}

\subsubsection{Changes required}
