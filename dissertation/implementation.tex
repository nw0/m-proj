\documentclass[dissertation.tex]{subfile}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}

\wip{Problems, details}
Optimisations not possible, \texttt{no\_std}.


\section{Overview}
\wip{What is this chapter for?}

This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.

\wip{Sectional overview might be useful}

\subsection{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM a backend for compilation.
The CTSRD project also develop a fork of LLVM with support for the
current CHERI implementation, with changes to the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.


\section{Strategy}
\label{sec:impl-what}

One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.

In order to evaluate \wip{(evaluate what?)} Rust on CHERI, I identified
a minimal necessary subset of the standard library:

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, used in the evaluation (Section~\wip{x}).
\end{description}

The rest of the standard library includes \wip{helpful things e.g. IO},
where capabilities are not immediately relevant.
\wip{So?}

Some modification of these libraries was needed for them to work, as
Section~\ref{sec:impl-divergences} details. \wip{So?}


\section{Differences arising from the CHERI target}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
This section documents these differences, their implications, and the
modifications required to compile Rust for CHERI.

\wip{remove list}
\begin{itemize}
    \item A pointer width of 128 bits.
    \item Use of LLVM address spaces other than 0, the default.
    \item The inability to arbitrarily manipulate pointers through
    unsafe code. In particular, certain routines in the standard library
    will not compile.
    \item The impossibility of indexing by pointer-width sized integers,
    or using these in operations such as \texttt{ptrtoint}.
    This is entirely consistent with LLVM, but the Rust compiler assumes
    otherwise.
    \item \wip{usize, uintptr\_t, size\_t}
\end{itemize}


\subsection{Definitions of pointers and indices}
\label{sec:impl-width}

\subsubsection{Differences}
In Rust, a \texttt{usize} is defined to be a pointer-sized integer,
conventionally equivalent to C's \texttt{uintptr\_t}, which \emph{may
not be equivalent to \texttt{size\_t}}~\cite{rust-rfc-isize}.
The width of a \texttt{usize} is derived from the data layout's pointer
width, which is 128 bits for a CHERI capability.

\subsubsection{Changes required}

\wip{128 not supported because of const\_eval}

\wip{purecap abi, chericap, etc.}

\wip{memset.i128}

\wip{ptrtoint, intcasts}


\subsection{Manipulation of pointers}
\label{sec:impl-manipulation}

\subsubsection{Differences}

\wip{e.g.~memchr}

\subsubsection{Changes required}
