\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}

\wip{Problems, details}
Optimisations not possible, \texttt{no\_std}.


\section{Overview}
\wip{What is this chapter for?}

This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.

\wip{Sectional overview might be useful}

\subsection{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM as a backend for compilation.
The CTSRD project also develop a fork of LLVM with support for the
current CHERI implementation, with changes to the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.

\subsubsection{Bugs in the LLVM backend}
\todo{Rust advertises this in general; I also found some errors from
unusual code paths---generally to do with i128s}


\section{Strategy}
\label{sec:impl-what}

One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.

In order to evaluate \wip{(evaluate what?)} Rust on CHERI, I identified
a minimal necessary subset of the standard library:

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, used in the evaluation (Section~\wip{x}).
\end{description}

The rest of the standard library includes \wip{helpful things e.g. IO},
where capabilities are not immediately relevant.
\wip{So?}

Some modification of these libraries was needed for them to work, as
\Cref{sec:impl-divergences} details. \wip{So?}


\section{Differences arising from the CHERI target}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
This section documents these differences, their implications, and the
modifications required to compile Rust for CHERI.


\subsection{Pointer width of 128 bits}
\label{sec:impl-width}

\subsubsection{Differences}
Under pure capability mode in CHERI128, all pointers are 128-bit wide
capabilities.
The Rust compiler has built-in support for 16-, 32-, and 64-bit
pointers, through compile-time macros; these are primarily used to
determine the \texttt{usize} (\Cref{sec:rust-usize}).

\subsubsection{Implications and changes}
This meant defining a \texttt{usize}, and exposing a 128-bit integer
type from LLVM as suitable for this value.
As \Cref{sec:rust-usize} shows, it was not possible to use a
64-bit \texttt{usize}, with its own implications.

Additionally, the Rust compiler instructs LLVM to generate
pointer conversions to and from \texttt{i128}s; only 64-bit conversions
are permitted.
Likewise, intrinsics such as \texttt{memset} are indexed using
\texttt{i128}s by Rust.
Extra instructions were inserted to extend or truncate integer types
around these operations.
It is unclear if these could be optimised, but resolving the
pointer-width and index tension (\Cref{sec:rust-usize}) should
resolve this.


\subsection{Address spaces}

\subsubsection{Differences}
There is no support in the Rust compiler to use LLVM address spaces
other than 0, the default.
By implication, there is also no support for multiple address spaces
within or across compilation units.

\subsubsection{Changes required}
As only one address space is recognised, I decided to use pure
capability mode, in which all pointers are capabilities, rather than
hybrid mode, which accepts untagged pointers as well.
Minor changes were made to refer to Rust's
\texttt{instruction\_address\_space} for all pointers, instead of only
pointers to types.


\subsection{Manipulation of pointers}
\label{sec:impl-manipulation}

\subsubsection{Differences}
\clar{Is this really a problem? Known: using iterators causes
compilation (with optimisations) to fail due to (pointer manipulation?).
But I can no longer compile with optimisations anyway---out of scope.
Worth noting as a current blocker.}

\wip{Consider showing MIPS generated code: prove roundtrip exists}

CHERI does not support round-tripping between pointers and integers.

\subsubsection{Changes required}
This is not a current problem for this project, as it does not attempt
to compile the core libraries with optimisations.
While the core libraries do not attempt to dereference pointers cast
from integers, built-in slice iterators attempt this \wip{evidence?}.

Note that Rust is considering implementing the integer-pointer cast
model proposed by Kang et
al.~\cite{kang-intptrcast,rust-miri-intptrcast}
\footnote{To be clear, this does \emph{not} suggest that pointers and
integers will be freely cast and used. However, it highlights that
Rust's memory model is very much under debate and that future
optimisations in the Rust compiler may invalidate this section.}


\subsection{Targeting CHERI}

\subsubsection{Differences}
CHERI is an extension to the big-endian 64-bit MIPS architecture.
A target specification was added to the Rust compiler, specifying the
pure-capability ABI, and the CPU.

\subsubsection{Changes required}
Modify Rust compiler to pass on target information such as
\texttt{purecap} ABI and use the \texttt{cheri128} CPU.


\section{Other challenges and incompatibilities}
\clar{Correct section to talk about 64-bit conversion?}

\end{document}
