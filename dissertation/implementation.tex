\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}


\section{Overview}

\todo{Rewrite, sectional overview?}
This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.
It details the strategy taken, defining the scope of the project, and
the differences of Rust to other languages which influence any effort to
port Rust to CHERI.

\todo{Distinguish compiler changes and libcore changes. Mention libcore
changes explicitly: e.g. memchr---there are only about 5 of these.}

\section{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM as a backend for compilation.
The CTSRD project maintains a fork of LLVM with support for the
current CHERI implementation, which extends the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.

\subsection{Incompatibilities with the LLVM backend}
Due to the pointer width and index size divergence
(\Cref{sec:rust-usize}), two incompatibilities were found with the CHERI
LLVM backend.
These have been fixed in the current version.

\begin{itemize}
    \item Rust may attempt to generate an unusual pointer offset when
    calling or returning from functions.\footnote{Fix at \url{https://github.com/CTSRD-CHERI/llvm-project/commit/39cfdf711a759a4799bd32f50af07f5f6f43c987}.}
    \item Rust sometimes attempts to generate unaligned loads.
    This is not possible in the pure capability ABI.\footnote{Fix at \url{https://github.com/CTSRD-CHERI/llvm-project/commit/d8e6acf3d4094270cd55b70341a6f9c4d032db81}.}
\end{itemize}

\section{Strategy}
\label{sec:impl-what}

\subsection{Host platform}
One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This is achieved by cross-compilation from an amd64 FreeBSD host; other
host platforms should work if they are able to compile the CHERI SDK.

\subsection{Rust functionality on CHERI}
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.
This avoids the hurdle of dealing with multiple LLVM address spaces and
pointer widths, not supported in the Rust compiler
(\Cref{sec:impl-addrspace}).

In order to evaluate Rust on CHERI, I identified
a minimal necessary subset of the standard library, listed below.
Not included is the bulk of the Rust standard library, which provides
filesystem and network support, general IO, interfaces to operating
system synchronisation and threading, and others.
I consider these not to have critical significance to capabilities in
standalone Rust programs.

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    It also includes support for calling to foreign function interfaces
    (FFI), unicode and number formatting, etc.
    It could be thought of as a modern version of the standard C
    headers, apart from the core definitions it provides, which would be
    built into a compiler.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, demonstrated in the evaluation
    (\Cref{sec:eval-micro-push,sec:eval-micro-repeat}).
\end{description}

Other parts of the standard library will compile for CHERI, but they are
not as central to running Rust programs.
I have not included them here in order to focus on evaluating the Rust
compiler and a core set of features.

\Cref{sec:impl-divergences} details modifications to the compiler and
these libraries required to compile Rust programs.

\subsection{Compiler optimisations}
Finally, optimisations are \emph{not} used.
Optimisations are not supported at this point as they cause the Rust
compiler to invoke LLVM APIs with values not supported by the CHERI
backend, such as offsets of 128 bits.
\Cref{sec:impl-width} discusses this briefly.


\section{Differences arising from the CHERI target}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
This section documents these differences, their implications, and the
modifications required to compile Rust for CHERI.


\subsection{Pointer width of 128 bits}
\label{sec:impl-width}

\subsubsection{Differences}
Under pure capability mode in CHERI128, all pointers are 128-bit wide
capabilities.
The Rust compiler has built-in support for 16-, 32-, and 64-bit
pointers, through compile-time macros; these are primarily used to
determine the \texttt{usize} (\Cref{sec:rust-usize}).

The immediately obvious solution, attempting to support a 64-bit index
size alongside a 128-bit pointer width was met with a non-functional
compiler; the target's pointer width is also used in more than 50
locations in the compiler.
If the intent behind each usage can be distinguished, a more functional
fix might be forthcoming.

\subsubsection{Implications and changes}
This meant defining a \texttt{usize}, and exposing a 128-bit integer
type from LLVM as suitable for this value.
As \Cref{sec:rust-usize} shows, it was not possible to use a
64-bit \texttt{usize}, with its own implications.

Additionally, the Rust compiler instructs LLVM to generate
pointer conversions to and from \texttt{i128}s; only 64-bit conversions
are permitted.
Likewise, intrinsics such as \texttt{memset} are indexed using
\texttt{i128}s by Rust.

Extra instructions were inserted to truncate the index (\texttt{len})
variable to 64 bits before every such operation.
This is problematic for two reasons.
First, such a change is prone to leaving out some intrinsics which may
silently fail, leaving the process open to functional errors.
Second, use of 128-bit integers is slow on CHERI, and unnecessary
casting also generates unnecessary instructions.
It is unclear if these could be optimised, but resolving the
pointer-width and index tension (\Cref{sec:rust-usize}) should
resolve this.


\subsection{Address spaces}
\label{sec:impl-addrspace}

\subsubsection{Differences}
There is no support in the Rust compiler to use LLVM address spaces
other than 0, the default.
By implication, there is also no support for multiple address spaces
within or across compilation units.

\subsubsection{Changes required}
As only one address space is recognised, I decided to use pure
capability mode, in which all pointers are capabilities, rather than
hybrid mode, which accepts untagged pointers as well.
This allows all pointers to refer to LLVM address space 200, rather than
having to mix two address spaces for capability and non-capability
pointers.
Minor changes were made to refer to Rust's
\texttt{instruction\_address\_space} for all pointers, instead of only
pointers to types.


\subsection{Targeting CHERI}

\subsubsection{Differences}
CHERI is an extension to the big-endian 64-bit MIPS architecture.
A target specification was added to the Rust compiler, specifying the
pure-capability ABI, and the CPU.

\subsubsection{Changes required}
Modify Rust compiler to pass on target information such as
\texttt{purecap} ABI and use the \texttt{cheri128} CPU.


\section{Other challenges and incompatibilities}
\clar{Correct section to talk about 64-bit conversion?}

\end{document}
