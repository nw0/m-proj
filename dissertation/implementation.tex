\documentclass[dissertation.tex]{subfile}

\chapter{Compiling Rust for CHERI}
\label{ch:impl}

\wip{Problems, details}
Optimisations not possible, \texttt{no\_std}.


\section{Overview}
\wip{What is this chapter for?}

This chapter discusses key details in compiling Rust for CHERI, as
opposed to other architectures.

\subsection{The Rust compiler and LLVM}
\label{sec:impl-rustllvm}

Rust uses LLVM a backend for compilation.
The CTSRD project also develop a fork of LLVM with support for the
current CHERI implementation, with changes to the MIPS backend to
support CHERI targets, and generic code to handle
capabilities~\cite{cheri-prog-guide}.


\section{Strategy}
\label{sec:impl-what}

One contribution of this project is an extension of the Rust compiler to
target FreeBSD on CHERI128.
This extension exclusively targets \emph{pure capability mode}, where
all pointers are capabilities~\cite{cheri-prog-guide}.

In order to evaluate \wip{(evaluate what?)} Rust on CHERI, I identified
a minimal necessary subset of the standard library:

\begin{description}
    \item[\texttt{libcore}] for key definitions of traits and types,
    typechecking, compiler intrinsics, and other fundamental operations.
    \item[\texttt{liballoc}] for heap allocation and built-in data
    structures and operations on them.
    \texttt{liballoc} also included two (patched) vulnerabilities in the
    Rust standard library, used in the evaluation (Section~\wip{x}).
\end{description}

The rest of the standard library includes \wip{helpful things e.g. IO},
where capabilities are not immediately relevant.
\wip{So?}

Some modification of these libraries was needed for them to work, as
Section~\ref{sec:impl-divergences} details. \wip{So?}


\section{Notable differences}
\label{sec:impl-divergences}

The \cuf target has several differences to most existing targets in the
Rust compiler.
These can be split in two categories, discussed in
Sections~\ref{sec:impl-width} and~\ref{sec:impl-manipulation}.

\begin{itemize}
    \item A pointer width of 128 bits.
    \item Use of LLVM address spaces other than 0, the default.
    \item The inability to arbitrarily manipulate pointers through
    unsafe code. In particular, certain routines in the standard library
    will not compile.
    \item The impossibility of indexing by pointer-width sized integers,
    or using these in operations such as \texttt{ptrtoint}.
    This is entirely consistent with LLVM, but the Rust compiler assumes
    otherwise.
    \item \wip{usize, uintptr\_t, size\_t}
\end{itemize}

\subsection{Pointer width and index sizes}
\label{sec:impl-width}

In Rust, a \texttt{usize} is defined to be a pointer-sized integer,
conventionally equivalent to C's \texttt{uintptr\_t}, which \emph{may
not be equivalent to \texttt{size\_t}}~\cite{rust-rfc-isize}.
The width of a \texttt{usize} is derived from the data layout's pointer
width, which is 128 bits for a CHERI capability.

\wip{AS200}

\wip{128 not supported because of const\_eval}

\subsection{Manipulation of pointers}
\label{sec:impl-manipulation}

\wip{e.g.~memchr}


\section{Modifications to the compiler and standard library}
\label{sec:impl-modification}

\wip{purecap abi, chericap, etc.}

\wip{memset.i128}

\wip{ptrtoint, intcasts}
