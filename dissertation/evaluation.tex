\documentclass[dissertation.tex]{subfile}

\chapter{Evaluation}
\label{ch:eval}

\section{Objectives}
This project evaluates whether Rust is particularly suited to running on
CHERI.
Chapter~\ref{ch:impl} defined the scope of this evaluation, and
discussed the compromises that were made to compile Rust's core
libraries for CHERI.

The key points of this evaluation are:

\begin{itemize}
    \item What benefits does running on a CHERI architecture have for Rust?
    More concretely, how convincing are the safety and performance
    improvements as opposed to other platforms such as x86 and MIPS?
    (Section~\ref{sec:eval-rust})
    \item Can the safety guarantees and boundaries of unsafe code be
    changed with the use of capabilities, or: do capabilities generate
    different definitions of unsafe code?
    For example, we can guarantee that an FFI call does not change the
    contents of a buffer.
    \item What benefits do Rust programs and a compilation toolchain
    have for CHERI?
    Specifically, do borrow semantics and object lifetimes naturally
    translate to capabilities?
    Generally, are safe languages easier to port to CHERI? Do they
    derive more benefit from capabilities than unsafe languages?
    (Section~\ref{sec:eval-cheri})
\end{itemize}


\section{Benefits to Rust from CHERI capabilities}
\label{sec:eval-rust}

\subsection{Removal of bounds checks}
Look at optimised MIPS code and performance---not much to be gained?
But: no unwind?
Compiler likely/unlikely hints (e.g.~panic) doesn't do anything for optimised code?


\subsection{Traditional vulnerabilities in Rust}
\label{sec:rust-vulns}

\wip{Buffer overflows and microbenchmarks}

One class of attacks that Rust aims to mitigate is buffer overflows.
In Safe Rust, bounds checks are inserted (Figure~\ref{lst:rust-index})
to prevent out-of-bounds accesses and writes.

\begin{figure}[ht]
\begin{lstlisting}
impl<T> SliceIndex<[T]> for usize {
    #[inline]
    fn index(self, slice: &[T]) -> &T {
        // N.B., use intrinsic indexing
        &(*slice)[self]
    }
}
\end{lstlisting}
\caption{\wip{rewrite; asm} Rust's intrinsic indexing, which applies to
arrays and vectors.}
\label{lst:rust-index}
\end{figure}

However, as Section~\ref{sec:rust-unsafe} discusses, checks are
sometimes omitted for performance.
An example of this is the \texttt{repeat} function on slices, which
returns a vector containing a slice repeated
(Figure~\ref{lst:slice-repeat}).
Unfortunately, this particular optimisation contained a flaw: a buffer
overflow occurs if the length of returned vector would exceed the
target's \texttt{usize} (essentially, \texttt{size\_t}).

\begin{figure}[ht]
\begin{lstlisting}
impl<T> [T] {
    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {
        // omitted: trivial n = 0 case
        let mut buf = Vec::with_capacity(self.len() * n);

        buf.extend(self);
        {
            let mut m = n >> 1;
            while m > 0 {
                unsafe {
                    // memcpy existing elements to double the length
                }
            }
        }
        // omitted: copy into the remainder of the vector
    }
}
\end{lstlisting}
\caption{\wip{rewrite} Rust's slice \texttt{repeat}, from
\texttt{alloc::slice}. Parts omitted for brevity. This code will attempt
to write beyond the end of a buffer.}
\label{lst:slice-repeat}
\end{figure}

This is difficult to exploit, as it would require a long slice or a
large number \(n\) of repetitions, increasing the change of a
segmentation fault.
Nonetheless, it is certainly not thread-safe, and Rust does target
platforms with 16-bit \texttt{usize}, i.e.~at most \(65,536\) elements,
making an attack plausible, if not possible.
\wip{What values would work?}

\wip{The other microbenchmark?}

\subsection{Unsafe semantics}

Sealed capabilities, FFI and capabilities---maybe some FFI code can be
made safe!
Not everything is unsafe any more? Dereferencing arbitrary pointers now
guaranteed to crash rather than leak.


\section{Benefits to CHERI as a Rust target}
\label{sec:eval-cheri}

\clar{Why Rust is a natural choice for CHERI?}

\subsection{Borrow semantics and object lifetimes}
Rust's semantics mean that programmers are less inclined to do
interesting pointer manipulations or storage, so porting might be easy.
On the other hand, CTSRD previously discovered that most C code isn't
that bad in this regard?

Better defined semantics? Less room for miscompilation?
If Rust is already fast, will CHERI make it even faster -> natural
choice? Since CHERI adds smaller overheads than e.g.~C.

Read the CHERI-JNI paper for inspiration.
