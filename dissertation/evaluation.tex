\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Evaluation}
\label{ch:eval}

\section{Objectives}
\Cref{ch:impl} defined the scope of this evaluation, and
discussed the compromises that were made to compile Rust's core
libraries for CHERI.

This chapter contains the main evaluation on the benefits and detriments
of porting Rust to CHERI.
The key questions this evaluation seeks to address are:

\begin{description}
    \item[\Cref{sec:eval-cheri}] What implications do Rust programs and a
    compilation toolchain have for CHERI?
    Specifically, how do Rust's unique characteristics---its borrow
    checker and lifetime model, temporal safety guarantees, small
    runtime---translate to a capability architecture?
    Do they complement or overlap the functionality provided by CHERI?
    \item[\Cref{sec:eval-rust}] What implications does running on a
    CHERI architecture have for Rust?
    More concretely, what are the safety and performance differences
    from running on other platforms such as x86 or MIPS?
    \item[\Cref{sec:eval-bugs}] Can CHERI capabilities mitigate or prevent
    vulnerabilities in Rust, and what is the nature of these flaws?
    Do they manifest differently in Rust, and can they be mitigated by
    other means?
    If C equivalents for these flaws exist, what nature do they take and
    does CHERI behave similarly? \wip{rework}
    If equivalents in other safe languages exist\ldots
    \item[\Cref{sec:eval-othersafe}] What are the general concerns when
    porting a safe language to CHERI or other capability architectures?
    Generally, are safe languages easier to port to CHERI? Do they
    derive more benefit from capabilities than unsafe languages?
    \wip{Why hasn't anyone written about doing this?}
    \item[\Cref{sec:eval-betterunsafe}] How can the safety guarantees
    and boundaries of unsafe code be changed with the use of CHERI
    capabilities, or: do capabilities give rise to a different natural
    definition of unsafe code?
    What insight does this provide for language design and
    non-capability platforms?
\end{description}


\section{Errors leading to memory violations in Rust}
\label{sec:eval-bugs}

Despite Rust's attention to safe language design, programmer error is
still a rich source of potential vulnerabilities.
While the Rust community is generally conscious about memory safety and
security, nowhere is this more true than with the language and compiler
developers.

This section covers four entirely unrelated memory safety flaws
discovered in the Rust standard library, all preventable with CHERI
capabilities.
Where relevant, demonstrative microbenchmarks were performed on either
CheriBSD on Qemu-CHERI with 128-bit capability pointers, or FreeBSD~11.2
(amd64) for the non-capability comparison.
In all cases, the Rust compiler was as described in
\Cref{ch:rust,ch:impl}, specifying the target as appropriate.


\subsection{Pushing to a \texttt{VecDeque}: off-by-one error leads to out-of-bounds write}
\label{sec:eval-micro-push}

\subsubsection{Cause}
Rust's \texttt{VecDeque} is a circular data structure stored on a
buffer.
When this buffer is expanded, elements stored at its (former) end must
be moved to its new end.
This error was caused by incorrectly using the public capacity, accessed
by \texttt{self.capacity()}, instead of the private (raw) capacity of
the buffer, \texttt{self.cap()}
(\Cref{lst:deque-defs})~\cite{rust-pr-reserve,rust-issue-deque-append}.

\begin{figure}[ht]
    \lstinputlisting{listings/deque-defs.rs}
    \caption{
        The public-facing definitions for a \texttt{VecDeque}'s
        capacity, and pushing to the end.
        It will not escape the reader's attention that the
        \texttt{capacity()} might be mistaken for the \texttt{cap()}, a
        likely cause of this error.
        These definitions are still current in Rust's built-in data
        structures.
        \texttt{push\_back} annotated with implicit precondition.
    }
    \label{lst:deque-defs}
\end{figure}

Subsequently, the pointer to the deque's \texttt{head} would point to
the address immediately after the buffer, rather than its start.
Pushing to the back of the deque then attempts to write to the address
after the buffer, rather than within it.

This appears to have been caused by the similarity of the method names
leading to an off-by-one error.

\subsubsection{Demonstration microbenchmark}
I checked that this spatial violation is caught by CHERI capabilities,
but is not detected on x86 FreeBSD.
Sample code is shown in \Cref{lst:micro-capacity}.

\begin{figure}[ht]
    \lstinputlisting{listings/micro-capacity.rs}
    \caption{
        A program which writes beyond the end of an allocated
        \texttt{VecDeque} buffer.
        An off-by-one error in \texttt{reserve} results in an unsound
        call another function, updating \texttt{head} to 32.
        Under x86 without capabilities, the program terminates normally,
        printing output as shown in the
        comments.{\protect\textsuperscript\textdagger}
        With CHERI capabilities, execution continues until line~12, which
        traps due to a length violation.
        \\ {\footnotesize \protect\textdagger\ The \texttt{prntf!} macro
        is \emph{not} built-in; I define it for convenience. See
        \cref{foot:prntf} on \cpageref{foot:prntf}.}
    }
    \label{lst:micro-capacity}
\end{figure}

Had another data structure been allocated after the deque, its start
would have been overwritten by the pushed element.
However, I was unable to force this situation without modifying the
allocator for the purpose.

\subsubsection{Observations}
This scenario is a plain example of a bounds violation that can be
prevented using capabilities.
Had the underlying implementation not used an unchecked write (line 12
of \Cref{lst:deque-defs}), this would also have been prevented by Rust's
bounds checks, as the \texttt{VecDeque} is backed by a vector.
This is an interesting lesson: bounds checks are useful not only for the
end-programmer, but also (presumably meticulous) language developers.

Note that whether this exceeds the bounds is implementation specific!
The existing implementation will reserve space for 32 elements here, but
if more space had been reserved by \texttt{with\_capacity} or its
underlying code (e.g.\ 64 elements), the object bounds would have been
correspondingly wider.
In that case, it would only be detected if the value was written using
the built-in bounds-checking indexing, although the pushed value would
still disappear.


\subsection{Slice \texttt{repeat}: integer overflow leads to buffer overflow}
\label{sec:eval-micro-repeat}

\subsubsection{Cause}
This flaw arose from an unchecked write, one pattern of optimisation
using Unsafe Rust covered in \Cref{sec:rust-unsafe}.
It occurs in the \texttt{repeat} function on slices
(\Cref{lst:slice-repeat}), which returns a vector containing a slice
repeated as specified by the parameter.
Here, a buffer overflow occurs when the length of returned vector would
overflow the target's \texttt{usize}.

\begin{figure}[ht]
    \lstinputlisting{listings/slice-repeat.rs}
    \caption{
        Rust's slice \texttt{repeat}, from \texttt{alloc::slice}.
        Part omitted for brevity.
        This code attempts to write beyond the end of a buffer.
        The error is in line~5; it was fixed by checking the
        multiplication against integer overflow.
    }
    \label{lst:slice-repeat}
\end{figure}

This appears to be a simple integer overflow translating to a buffer
overflow.
Note that this overflow will be caught when compiling Rust code in debug
mode, as integer overflow checks will apply to all arithmetic; release
mode instead uses two's complement and is \emph{not} undefined.

\subsubsection{Demonstration microbenchmark}
I did not demonstrate this by calling the \texttt{repeat} method as
given: as noted below, attempting to copy more than \(2^{64}\) elements
is difficult to do in a controlled way.
Instead, \Cref{lst:micro-repeat} shows the code used to demonstrate the
effects of this bug.

\begin{figure}[ht]
    \lstinputlisting{listings/micro-repeat.rs}
    \caption{
        Demonstration of how an integer overflow can lead to a buffer
        overflow when repeating a slice.
        Three iterations of the copy are performed (lines 20--31) to
        ensure \texttt{v} is overwritten on the non-capability machine;
        with capabilities this traps on the first iteration.
    }
    \label{lst:micro-repeat}
\end{figure}

I chose values carefully to demonstrate the overflow on the test
machine; other values may work depending on the operating system and
allocator.

\subsubsection{Observations}
This is difficult to exploit, as it would require a long slice or a
large number \(n\) of repetitions, increasing the chance of a
segmentation fault.
An exploit would probably have to interrupt the write before too many
iterations of the loop, and either spawn a new process or stop the
thread executing this loop before the operating system stopped it.


\subsection{Out-of-bounds indexing into a reversed slice}

\subsubsection{Cause}
An unhandled unsigned integer wrap-around could lead to out-of-bounds
slice indexing through its reverse iterator~\cite{rust-pr-reverse}.
\Cref{lst:bug-reverse} shows the relevant implementation, defined in the
core library.

In this situation, the assumptions about the underlying iterator
implementation are not obvious, and thus not considered when writing
this method.

\begin{figure}[ht]
    \lstinputlisting{listings/bug-reverse.rs}
    \caption{
        Previous implementation of indexing into a reversed slice.
        If \texttt{amt - index - 1 < 0}, the index wraps, attempting to
        access an index larger than the indexable region.
        This may be unsafe depending on the underlying implementation.
        This was fixed by checking that \texttt{amt > index} before
        indexing, returning \texttt{None}
        otherwise~\cite{rust-commit-reverse}.
    }
    \label{lst:bug-reverse}
\end{figure}

\subsubsection{Observations}
A very large index (i.e.\ close to \texttt{usize::MAX}) could be passed
to the reverse indexing function to get values slightly beyond the end
of the slice.
As `slice' suggests, they frequently represent a view into a larger
slice, so this could reasonably be expected to be defined.

Whether this is possible is implementation-dependent; if the
reverse \texttt{idx} is expected to handle bad values, then the
underlying \texttt{idx} should arguably also handle them.
If anything, this example  and its resolution is an example of the
safety awareness of Rust developers, rather than a fundamental bug.


\subsection{Iterator method violates Rust's uniqueness of shared references}
\label{sec:eval-bug-vec-mut}

\subsubsection{Cause}
An iterator method in the core library should return a mutable slice
from a mutable iterator.
Instead, it returns a mutable slice for any iterator.
\Cref{lst:bug-mutslice} shows that it does this by calling an unsafe
method which operates on raw pointers~\cite{rust-issue-vec-mut}.

\begin{figure}[ht]
    \lstinputlisting{listings/bug-as_mut_slice.rs}
    \caption{
        Built-in method returning a mutable slice for a (mutable)
        iterator: except it accepts immutable iterators also.
        This violates Rust's temporal guarantee that mutable references
        are never shared.
    }
    \label{lst:bug-mutslice}
\end{figure}

This bug appears to be caused by copying and pasting the Iterator
\texttt{as\_slice} method when writing \texttt{as\_mut\_slice}.
A demonstration of the fallibility of programmers and motivator for safe
syntax, neither the language nor the runtime helps in this situation.

\subsubsection{Observations}
This is a clear violation of one of Rust's temporal safety guarantees,
that mutable references must not ordinarily be shared.
While this is not strictly undefined behaviour, attempting to mutate the
returned object is, defeating the point of getting a mutable slice.

Though this error leads to temporal unsafety, this could be prevented by
passing a read-only capability for an immutable borrow.
\Cref{sec:eval-rust-enforce-immut} discusses this in more detail.


\section{Implications of Rust semantics for CHERI targets}
\label{sec:eval-cheri}

Capabilities are typically seen as a mechanism to improve the security
of languages and runtimes.
It is therefore slightly unusual to consider how a language might
improve capabilities.
Nevertheless, this section considers how Rust complements CHERI
capabilities, presenting a contrast to other safe languages.

\subsection{Ownership gives complementary temporal safety}
\label{sec:eval-cheri-spatial-temporal}

One of Rust's main objectives and early selling points was
\emph{fearless concurrency}.
It uses its ownership model and type system to manage temporal memory
safety~\cite{rust-trpl-book}.
These mechanisms prevent dangling pointers or use-after-free in Safe
Rust (\Cref{sec:rust-borrow}), although the use of raw pointers in
Unsafe Rust can bypass these checks.

By contrast, CHERI's initial focus was on spatial integrity, only later
moving to consider temporal safety by means of tagging.
Temporal safety is provided by marking capabilities as \emph{local} or
\emph{global}, which restricts the flow of capabilities and thereby
preventing their leakage~\cite{cheri2015}.

However, this provision only yields atomic pointer updates and
identifiability of pointers;
it is not precise enough to guarantee safety across thread or process
boundaries, such as foreign function interface (FFI) and system
calls~\cite{cheri-2019-abstract}.
While Rust does not provide temporal protection against other processes
misusing its resources, its ownership model guarantees that a thread
which has yielded a resource does not attempt to modify it while it has
been lent out.
Likewise, the ownership model prevents similar conflicts within a
concurrent Rust program, complementing CHERI's spatial integrity.

Note: \Cref{sec:eval-rust-xprocess} discusses how CHERI capabilities can
be used to make Rust's FFI or cross-process calls safer.

\subsubsection{Temporal safety under CHERI}
While not inherent to capability systems, CHERI enables a form of
revocation, preventing dangling pointers from being dereferenced.
See \Cref{sec:eval-rust-use-after-free} for an example of how revocation
can be useful in Rust.


\subsection{Stronger pointer provenance model in Rust}
\label{sec:eval-cheri-provenance}

With a fully-functional Rust compiler for CHERI, porting Rust programs
and crates should be relatively straightforward.
In particular, common compatibility issues in CHERI due to pointer
provenance~\cite{cheri-2019-abstract} do not apply in Safe Rust,
as the compiler tracks object ownership comprehensively.\footnote{
An exception to this statement is the `pointer shape' issue; see
\Cref{sec:impl-width} for a discussion.
}

Due to Rust's lack of a specification and documented undefined
behaviour, programmers are discouraged from performing such
capability-incompatible pointer manipulation.
It is still unclear if problematic pointer manipulation is currently
undefined in Rust, but community discussions suggest that it might be in
future~\cite{rust-ucg-provenance}.
As such, unsafe code should not rely on patterns that break provenance
analysis in these ways.\footnote{
An example of a data structure which might not be implementable in Rust
(without exhibiting undefined behaviour) in the XOR linked list.
}


\subsection{Safer code patterns yields easier porting to CHERI}
\label{sec:eval-cheri-port}

Rust has been designed to guide programmers toward writing safe code,
and to highlight potentially dangerous operations.
Programmers have less cause to perform unusual or \emph{clever} pointer
manipulation, writing code that does not immediately compile for CHERI.
\Cref{sec:impl-div-lib} documented the limited incompatibilities in the
core library; most changes affect the compiler.

Nevertheless, one should recognise that the difficulty of porting C
programs to capability architectures and CHERI in particular is not
thought to be too onerous~\cite{capsicum-usability}.
This must be weighed against the prospect of updating the Rust compiler.


\subsection{Comparable performance to C}
\label{eval:cheri-perf}

While Rust possesses strong safety features, it also provides good
performance.
For this reason, it has garnered attention in applications as diverse as
astrophysics (favourable comparison to Fortran~\cite{blanco-astro}), GPU
programming (comparable to handwritten and domain-specific language
generated OpenCL~\cite{holk-gpu}), and garbage collection (comparable to
C~\cite{lin-gc}).
The Debian project maintains a set of toy benchmarks run against
user-submitted programs in diverse
languages~\cite{debian-benchmarksgame}, showing that Rust performs as
well as C and C++ under their testing problems and environment.
All three come well ahead of the next `safe' languages, Java and Go.

These suggest that Rust is capable of matching C under some
circumstances while being safer, making it a good choice in general.
If CHERI implementers are keen on augmenting hardware safety features
with a speedy, low-runtime language, then Rust makes a sensible choice,
especially for embedded platforms.


\subsection{Larger pointer size can be offset by removing redundant bounds information}
\label{sec:eval-cheri-memfoot}

Currently, any vector or array slice stores a pointer to the relevant
object and its length~\cite{blandy-orendorff}.
As bounds information can be derived from the CHERI capability pointer
to the same object, it is redundant to store the length.
Instead, a \texttt{CGetLen} instruction would be used to get the bounds
information when needed: notably this is not required when indexing into
the slice.
The overhead of a 128-bit pointer can therefore be offset by the removal
of a 64-bit length variable, negating the memory overhead for slices
which would apply in other languages.

\subsubsection{Impact on data structures}
Associating bounds information with pointers is a natural pattern for
slices, which have one fixed bound.
However, vectors have different bounds for the allocated space and the
initialised indices.
Currently, these are known as the \emph{capacity} and \emph{length} of
the vector respectively.
This tension can be resolved in two ways, both requiring capability
pointers to the allocation\footnote{
Monotonicity implies that access to allocated space must be continuously
pointed to in order to be used later.
}:

\begin{description}
    \item[Initialised length variable] This is similar to the current
    implementation, where the capacity variable can be dropped.
    This saves space, as a length variable would be a \texttt{usize} (64
    bits), where a capability would be 128 bits.
    However, bounds checks will be required for indexing into vectors,
    hence could not be completely removed from Rust compilation (to
    CHERI).
    \item[Slice capability pointer] A natural solution: this squares
    with Rust's type system, where indexing is provided by the
    \texttt{SliceIndex} trait implemented for slices.
    However this requires more space, and it is unclear if deriving a
    new slice capability for each push/pop operation on the vector will
    be faster or slower than updating a length variable.
    This should not affect concurrency when popping as CHERI
    capabilities support atomic operations: pushing would require the
    slice capability to be derived from the allocation capability, which
    could pose a problem.
\end{description}

\subsubsection{Memory overhead of CHERI capabilities}
The memory traffic overheads of CHERI capabilities for diverse C
benchmark programs is within 5--10\%~\cite{cheri-tagged-memory}, with
the greatest impact on pointer-heavy workloads.
In Rust, some overhead will still apply: notice that bounds are not
checked with every slice access, but pointers are always larger.
How this impacts cache usage is unclear, but it is not unreasonable to
suggest that overheads will be at most as large as under equivalent C
workloads.
\Cref{sec:eval-hybrid} outlines a strategy to reduce the memory
impact of CHERI capabilities in Rust.


\section{Spatial integrity in Rust from CHERI capabilities}
\label{sec:eval-rust}

This section explores how memory safety can be improved in the Rust
compiler and runtime by introducing CHERI capabilities.
\Cref{sec:eval-betterunsafe} instead considers how capabilities can be
used to reduce the danger posed by undefined behaviour, enabling changes
to the semantics of the language.

\subsection{Mitigation of traditional vulnerabilities}
\label{sec:eval-rust-vulns}

One class of attacks that Rust aims to mitigate is buffer overflows.
In Safe Rust, bounds checks are inserted (\Cref{sec:bg-rust-bounds})
to prevent out-of-bounds accesses and writes.

Nevertheless, as \Cref{sec:rust-unsafe} highlights, unchecked accesses
are sometimes used for optimisation, by reading or writing using raw
pointers.
These unsafe operations are just as susceptible to programmer errors as
their C analogues, giving rise to the bugs discussed in
\Cref{sec:eval-micro-repeat,sec:eval-micro-push}.
Capabilities can combat this by preventing out-of-bounds accesses.


\subsection{Bounds checks removal}
\label{sec:eval-rust-bounds}

With capabilities, bounds checks can be removed altogether: instead of
the default panic, a hardware interrupt will occur with each attempted
out-of-bounds access.
Most Rust programs do not handle panics, instead crashing the program:
this is the default behaviour.
If desired, CHERI length violations can be caught and the panic handler
invoked, rather than terminating the program directly.
Therefore the CHERI mechanism is fully compatible with the existing
panicking framework.

This is a low-impact improvement, as most bounds checks are elided with
compiler optimisations enabled; see \Cref{sec:rust-elision} for examples
where checks are already optimised.
However, they are unavoidable in some situations, such as random array
accesses.


\subsection{Sub-object bound enforcement}

In Rust, \emph{slices} can be created from continuous segments of an
iterable.
Slices can be passed to functions, only allowing them to refer to part
of an array, or a \emph{subslice}.
Using pointer manipulation, such a function could access indices of the
array which are not part of the slice.
This is not undefined behaviour as the pointer would point to a valid
part of the object, although it must be done in Unsafe Rust.

With CHERI capabilities, a subslice could be passed as a pointer with
bounds restricted to the relevant segment of the array.
It would then be impossible for a function to access the other elements
unexpectedly, again enforcing the principle of least privilege.

Likewise, this can apply to struct members, generalising the protection
to objects with known continuous layouts.
The cost of doing this is similar to that of enforcing immutability in
\Cref{sec:eval-rust-enforce-immut}.


\subsection{Use-after-free elimination in Safe Rust}
\label{sec:eval-rust-use-after-free}

As we have discovered, spatial integrity is not an absolute guarantee in
Rust.
Unsurprisingly, neither is temporal safety, even in \emph{Safe} Rust!

Consider the following example from the documentation, a simplified
version of the reference-counted container type, \texttt{Rc}, and its
simplified \texttt{Drop} implementation (\Cref{lst:eval-rust-rc-drop}).
By overflowing the reference count (using \texttt{mem::forget} if memory
usage is an issue), one can cause the pointed-to object to be
deallocated, even with outstanding references, defeating the reference
counter.
This creates a use-after-free bug~\cite{rust-nomicon-rc-leak}.

\begin{figure}[ht]
    \lstinputlisting{listings/rc-drop.rs}
    \caption{
        A potential use-after-free bug, if \texttt{ref\_count}
        overflows.
        This may occur in Safe Rust, as \texttt{drop} methods are always
        safe: the unsafety is encapsulated here, and also in
        \texttt{mem::forget}, which would be used to overflow the count.
        Example from the Rust documentation~\cite{rust-nomicon-rc-leak}.
    }
    \label{lst:eval-rust-rc-drop}
\end{figure}

This can be resolved by revocation, for which CHERI capabilities provide
a foundation by virtue of monotonicity and memory tagging.
Revocation would prevent programs from reading or modifying memory which
has been deallocated, or more importantly reallocated, another common
source of vulnerabilities.
Note that there are performance overheads associated with
revocation~\cite{cheri-v6}, and Rust's temporal guarantees mean that its
utility is largely constrained to unsafe code.
This is discussed further in \Cref{sec:eval-betterunsafe-reasons}.


\section{Capability sealing to protect Rust objects}

\emph{Capability sealing} can prevent a capability from being used to
mutate or dereference the memory it refers to, as described in
\Cref{sec:bg-cheri-sealing}.
This section describes how the Rust runtime can use this mechanism to
enforce program invariants.

\subsection{Preserving object immutability in Unsafe Rust}
\label{sec:eval-rust-enforce-immut}

Modifying an immutable object is undefined behaviour in Rust, and should
be prevented by the compiler in Safe Rust.
The only exception to this pattern is the \texttt{UnsafeCell},
modifications to which are explicitly excluded from being undefined
behaviour.
There, the programmer is expected to implement an object safely without
causing concurrency bugs.

However, the compiler does not prevent this invariant from being
violated in Unsafe Rust, where the programmer can essentially bypass the
type system by casting raw pointers.
There have been bugs in the standard library~\cite{rust-issue-vec-mut}
(\Cref{sec:eval-bug-vec-mut}) resulting in mutable references to
supposedly immutable objects.

Since mutating these is undefined, it is reasonable to protect them
from being written to, which can be accomplished with capabilities.
This enforces the principle of least privilege on shared references.
Sealing can be used to prevent mutation.

\subsubsection{Note on differences from C}
Enforcing C's \texttt{const} in hardware proved problematic for CHERI in
the past, due to functions like~\texttt{strchr} (C), which derive a
non-\texttt{const} (mutable) pointer from an immutable
one~\cite{cheri-prog-guide}.

\begin{lstlisting}[language=C]
char *strchr(const char *s, int c);
\end{lstlisting}

The proposal of deriving a read-only capability for each immutable
reference in Rust does not suffer this problem, as it is not possible to
derive a mutable reference from an immutable one.
Indeed, this idiom does not occur in Rust as immutability is conveyed by
the function signature.


\subsection{Preserving object immutability across FFI boundaries}
No amount of type-checking can prevent a foreign function from modifying
a supposedly immutable borrowed object, since they use raw pointers and
are not bound to Rust's semantics.

By passing a capability without write permissions to a function, this
particular cause of undefined behaviour can be eliminated.
This supports the use of \emph{least privilege} even across foreign
function interfaces.


\subsection{Protecting data from callback functions}
Another situation that benefits from least privilege are callbacks from
FFI code.
In this scenario, an FFI function might receive a pointer to data it is
expected not to access, but instead merely to return the pointer to the
original process at the correct time.

This can be enforced through capability sealing.
The foreign function would be unable to dereference the object, but the
capability could be unsealed by the original program to regain access to
the original data~\cite{cheri-v6}.
This allows less trusted code to handle Rust objects while still
guaranteeing integrity and confidentiality.


\subsection{Fine-grained object protection}
\label{sec:eval-capability-using-type}

As an extension of the previous sections, not only can specific objects
passed across unsafe or FFI boundaries be protected, but also objects
transitively accessed via those objects.
CHERI capabilities include an \emph{object type} field, on which sealing
and unsealing can be predicated; this can be used to protect a
`confidential object' type (and derivable types) from abuse by Unsafe
Rust or FFI functions.
This can easily be marked using a Rust trait.

To motivate this protection, consider a library written in Safe Rust.
Its authors may wish to restrict the ability of other code to abuse
Unsafe Rust to read its data, for instance to protect customer records.
Capability sealing presents a viable method to enforce this.

Note that accessing an object which one has a reference to is not
undefined.
Sealing to prevent pointer dereferences can therefore be used to enforce
invariants which other code may not conform to.
For instance, a high-performance data structure might attempt a deep
copy of its objects, which would be obstructed by sealing in the
scenario above.


\subsection{Efficacy and costs of sealing}
However, manipulating capabilities is not free and the overheads of
manipulating capabilities should be weighed against enforcement within
the existing type system, which is statically enforced but does not
protect against unsafe code.
Additionally, this does not solve the inherent potential for programmer
error in the compiler, such as incorrectly failing to seal a capability.


\section{Improved safety of FFI calls}
\label{sec:eval-rust-xprocess}

A quick survey of Rust crates that use FFI bindings shows that most of
them deal with some form of low-level behaviour, including encryption,
memory allocation, USB interfaces, and filesystem mounts.\footnote{
    Rust crates are published libraries.
    The reader may be interested to peruse a selection of crates at
    \url{https://crates.io/search?q=-sys};
    a \texttt{-sys} suffix conventionally denotes an FFI crate.
    \texttt{crates.io} is advertised as the ``Rust Package Registry''.
}
With performance or low-level access as the primary goal of most Rust
FFI calls, safety may not be a major concern, even if it could allow
arbitrary code execution in the Rust
program~\cite{szekeres-eternal-war}.

Most of the discussion below has to do with object capabilities and is
thus inherent in the use of CHERI capabilities, but system call
protection is a separate feature of CHERI compartmentalisation.
Watson et al.\ describe the mechanism and security implications with
regard to C~\cite{cheri2015}.
Many of the points apply to non-FFI code as well, although protection
across domain boundaries is perhaps more significant as FFI calls cannot
be type- or borrow-checked.

\subsection{Prevention of use-after-free from FFI}
The use of FFI functions can bypass Rust's object lifetime model, as
there is no way to ensure that an FFI function has not stored or leaked
references to borrowed Rust objects.
This can lead to later temporal unsoundness in the Rust program.

While this cannot be completely prevented with capabilities as-is,
\Cref{sec:eval-betterunsafe-reasons} discusses the possibility of using
revocations to manage this risk.

\subsection{Enforcement of object boundaries}
\clar{Demonstration microbenchmark?}

Objects can only be passed to C as raw pointers.
As such, a buffer overflow through an FFI function is no more difficult
than in C natively, and no less serious.

A simple example of an overflow opportunity uses the well-known source
of overflows which is a C string with a missing NUL terminating byte.
To overcome this, Rust strings instead store a length value and a byte
array, making them non-interchangeable with C strings.
This means, however, if that a programmer neglects to convert between
the formats, passing a Rust string to a C function will quickly lead to
an overflow.

Object capabilities easily protect against this by storing and enforcing
object bounds.
Importantly, they protect the rest of the calling program's address
space, preventing a cross-domain call from accessing data which was not
explicitly passed to it.

\subsection{Protection of system calls}
In addition to protecting the caller's memory, CHERI can be extended to
protect access to system calls in FFI functions.
This is achieved by funnelling system calls through classes which only
permit safe calls~\cite{cheri2015}.
A caller can thereby restrict the privileges of a callee function,
preventing bugs in called libraries from propagating to the host
program.


\section{Porting safe languages to capability architectures}
\label{sec:eval-othersafe}

\todo{Think about (categorise?) these:}
\begin{itemize}
    \item What are the major existing problems with the language?
    \item Existing vulnerabilities?
    \item What guarantees does the language provide?
    \item Where does it derive its safety from? Some type systems may
    have overheads that cannot be easily reduced.
    \item Is Cython still Python?
    \item Do you make code invalid? e.g.\ can no longer get change a
    const ptr to a mut ptr? memchr strikes again
    \item Assumptions about address spaces and pointers---do they
    already use fat/smart pointers?
    \item Are there multiple runtime implementations?
\end{itemize}


\section{Strengthening unsafety}
\label{sec:eval-betterunsafe}

This section considers the danger posed by undefined behaviour in Rust,
and how it can be mitigated by CHERI capabilities, enhancing the
semantics and guarantees of the language while not impeding compiler
transformations and optimisation.

I address four of the nine forms of undefined behaviour documented by
the Rust project, and show how they are made safer with capabilities.

\subsection{Rationale for Unsafe Rust}
In Safe Rust, the compiler accepts programs which avoid memory safety
problems using its type- and borrow-checkers.
Unsafe Rust enables programs which would not otherwise pass this static
analysis~\cite{rust-trpl-book}.

Programmers bypass these checks by using raw pointers, unsafe traits, or
using mutable static variables, all of which could violate temporal
memory safety.
Reaching undefined behaviour is possible with unsafe code, where it is
not supposed to be possible in Safe Rust.


\subsection{From unsafe code to undefined behaviour}
A requirement of the Rust language is that safe code should \emph{never}
be able to exhibit undefined behaviour: unsafe code must be handled
thoroughly such that safe functions are defined on all inputs.
Thus Unsafe Rust and undefined behaviour are inextricably linked.

Undefined behaviour in Rust is fairly simple to comprehend:
the core list contains only 9 points~\cite{rust-undef},\footnote{
\emph{The list is non-exhaustive}: in any case, Rust has no formal
semantics or specification, making the idea of particular undefined
behaviours rather arbitrary.}
none of which are challenging to avoid, unlike signed integer overflow
in C.
The following sections show how the CHERI architecture can be used to
restrict undefined behaviour, and thereby make Unsafe Rust safer.


\subsection{Restricting undefined behaviour with CHERI capabilities}
\label{sec:eval-betterunsafe-reasons}

The undefined behaviour below takes the form of invariants assumed by
the Rust compiler or LLVM; they all involve the usage of pointers or
references.
Transformations based on these assumptions are made safer, by
guaranteeing a trap if the invariant is violated.

\subsubsection{LLVM pointer aliasing rules}
Breaking LLVM's pointer aliasing rules is forbidden.
In essence, the rules state that a pointer may not be used to access
memory apart from those addresses it is based on.

CHERI capabilities rule this out, due to monotonicity.
In fact, they impose stronger conditions, as a capability formed by an
\texttt{inttoptr} cannot be dereferenced.

\subsubsection{Mutation of non-mutable data}
CHERI capabilities can prevent the mutation of data reached through a
shared reference by enforcing object immutability as detailed in
\Cref{sec:eval-rust-enforce-immut}.
In this case, the references are known to be immutable in Rust
semantics, so this is easy to compile and enforce.

\subsubsection{Enforcement of the \texttt{noalias} model}
Likewise, CHERI capabilities can rule out violations of LLVM's
\texttt{noalias} model in Rust by similar means.
To check this, first note that the model will not be violated in Safe
Rust, as the compiler enforced uniqueness of mutable references.
It is thus only necessary to prevent the mutation of an object through a
reference if other references to that object are being used.

This can be done by deriving a read-only capability for immutable
references.
As the compiler enforces the uniqueness of mutable references, the two
measures combined prevent violations of this model in unsafe code.

\paragraph{Caveat}
A mutable reference can first be converted to a raw pointer, and
subsequently duplicated in unsafe code.
This would prevent the Rust compiler from enforcing the uniqueness of
mutable references or generating non-writeable capabilities, abandoning
Rust's temporal safety guarantees.

\subsubsection{Dereferencing null or dangling pointers}
This invariant is traditionally used to show that a pointer is not
null or dangling, if it has been previously dereferenced.
That is to say a pointer which has already been dereferenced is safe to
dereference again, which ties in with the aliasing rules discussed
above.
It is then considered safe to optimise away null
checks~\cite{wang2013towards,llvm-undef-dce}, possibly causing an
invalid dereference.

While capabilities cannot prevent an attempt to dereference a pointer,
they can prevent dereferences from succeeding.
For instance, a null pointer or an arbitrarily-constructed pointer from
\texttt{inttoptr} will fail to dereference on CHERI, as it would not
possess a valid capability.
This removes much of the danger from dereferencing a null or dangling
pointer, by guaranteeing that it will trap rather than compromising the
integrity or confidentiality of memory.

\paragraph{Dangling pointers}
By themselves, capabilities do not offer protection against
dereferencing a dangling pointer, as they derive from a previously-valid
object.
However, revocation allows dangling pointers to be identified and
marked, preventing them from being used.


\section{Hybrid ABI: Minimising the memory footprint of CHERI capabilities}
\label{sec:eval-hybrid}
\todo{If Safe Rust is safe, save memory overhead of capabilities by only
placing objects reachable by unsafe code in AS200.
Note, though, that unsafe code in rife in libcore, so this may not be
helpful.
Also slices would need to be capability pointers, maybe.

This provides real benefits for using only safe code! And possibly
lower-footprint than C.}

\subsection{Safe Rust is memory safe}
Observe that the bugs covered in \Cref{sec:eval-bugs} occur in Unsafe
Rust: either from the exposure of unsafe methods as safe, thereby
failing to handle all the cases, or through errors in the unsafe code
itself.
This is no coincidence: Safe Rust is not expressive enough to generate
memory safety errors, as it lacks the memory manipulation primitives to
do so.
This is evinced by the additional actions programmers may take in Unsafe
Rust~\cite{rust-nomicon-safe-unsafe}.

Being satisfied that Safe Rust is indeed memory safe, references that
are only manipulated in Safe Rust need not be protected by capabilities,
reducing the overall memory overhead.


\subsection{Pointer provenance for Unsafe Rust}
Due to Rust's strong provenance model, all references can be traced to
their original object, and so can raw pointers generated from that
object.
Thus all references used in Unsafe Rust can be tracked to their
instantiation at compile time, and marked to indicate that a capability
pointer should be used.
Unsafe Rust code would therefore only encounter capability pointers.

Likewise, this analysis can determine all objects reached from unsafe
code: similar analysis is already performed to prevent modifying
immutable objects in Unsafe Rust.\footnote{
To be clear, Unsafe Rust can still be used to modify immutable objects
by casting to (Rust) raw pointers.
The provenance of these raw pointers is still tracked by the compiler.
}

Note that raw pointers can be manipulated to point to a different
object, even if this is undefined behaviour in Rust.
However, if each raw pointer is a capability pointer, such code will
still be unable to violate memory safety.


\subsection{Limitations of object reachability}


\section{Distinguishing pointer width and index sizes}
\label{sec:eval-usize}

\todo{Why `bytes that a pointer takes up' is not what you want, how to
fix this.
What needs to be defined? How far should you go.
Compare NSInteger, RISCV, clang/llvm.}


\section{Limitations}
\todo{128-bit usize means no sensible evaluation of generated
instructions, no opt means no eval of runtimes.
Do Rust heaps contain more pointers? out of scope
Rust has no spec---lots more UB.
Rust, CHERI under development and def of UB, capability impls might
change.}


\section{Summary}

\end{document}
