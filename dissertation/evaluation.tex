\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Evaluation}
\label{ch:eval}

\section{Objectives}
This project evaluates whether Rust is particularly suited to running on
CHERI.
\Cref{ch:impl} defined the scope of this evaluation, and
discussed the compromises that were made to compile Rust's core
libraries for CHERI.

The key points of this evaluation are:

\begin{itemize}
    \item What benefits does running on a CHERI architecture have for Rust?
    More concretely, how convincing are the safety and performance
    improvements as opposed to other platforms such as x86 and MIPS?
    (\Cref{sec:eval-rust})
    \item Can the safety guarantees and boundaries of unsafe code be
    changed with the use of capabilities, or: do capabilities generate
    different definitions of unsafe code?
    For example, we can guarantee that an FFI call does not change the
    contents of a buffer.
    \item What benefits do Rust programs and a compilation toolchain
    have for CHERI?
    Specifically, do borrow semantics and object lifetimes naturally
    translate to capabilities?
    Generally, are safe languages easier to port to CHERI? Do they
    derive more benefit from capabilities than unsafe languages?
    (\Cref{sec:eval-cheri})
    \item Lessons on porting a `safe' language to CHERI, or capability
    platforms in general. \wip{Wrong chapter?}
\end{itemize}


\section{Benefits to CHERI as a Rust target}
\label{sec:eval-cheri}

\subsection{Ownership gives complementary temporal safety}
\label{sec:eval-cheri-spatial-temporal}

\todo{CHERI seems to focus on spatial safety. What about revocation and
temporal safety? How helpful are Rust lifetimes and ownership?}

One of Rust's main objectives and early selling points was
\emph{fearless concurrency}.
It uses its ownership model and type system to manage temporal memory
safety~\cite{rust-trpl-book}.
By contrast, CHERI's initial focus was on spatial integrity, only later
moving to consider temporal safety through the means of tagging.
Temporal safety is provided by marking capabilities as \emph{local} or
\emph{global}, which restricts the flow of capabilities and thereby
preventing their leakage~\cite{cheri2015}.

However, this provision only yields atomic pointer updates and
identifiability of pointers;
it is not precise enough to use across thread or process boundaries,
such as FFI and system calls~\cite{cheri-2019-abstract}.
While Rust does not provide temporal protection against other processes
misusing its resources, its ownership model guarantees that a thread
which has yielded some resources does not attempt to modify them while
they are lent out.
Likewise, the ownership model prevents similar conflicts within a
concurrent Rust program, complementing CHERI's spatial integrity.

Note: \Cref{sec:eval-rust-xprocess} discusses how CHERI capabilities can
be used to make Rust's FFI or cross-process calls safer.


\subsection{Borrow semantics and object lifetimes}
\todo{Discuss provenance analysis and revocation.}


\subsection{Stricter semantics and reduced undefined behaviour}
\todo{Rust's semantics mean that programmers are less inclined to do
interesting pointer manipulations or storage, so porting might be easy.
On the other hand, CTSRD previously discovered that most C code isn't
that bad in this regard?}


\subsection{Comparable performance to C}
\todo{Faster than other managed languages. See Debian's benchmarks
comparing various languages, and note that capabilities might reduce
overheads.}


\section{Benefits to Rust from CHERI capabilities}
\label{sec:eval-rust}

\subsection{Traditional vulnerabilities in Rust}
\label{sec:eval-rust-vulns}

One class of attacks that Rust aims to mitigate is buffer overflows.
In Safe Rust, bounds checks are inserted (\Cref{lst:rust-index})
to prevent out-of-bounds accesses and writes.

\begin{figure}[ht]
\begin{lstlisting}
impl<T> SliceIndex<[T]> for usize {
    #[inline]
    fn index(self, slice: &[T]) -> &T {
        // N.B., use intrinsic indexing
        &(*slice)[self]
    }
}
\end{lstlisting}
\caption{\wip{rewrite; asm} Rust's intrinsic indexing, which applies to
arrays and vectors.}
\label{lst:rust-index}
\end{figure}

Nevertheless, as \Cref{sec:rust-unsafe} highlights, unchecked accesses
are sometimes used for optimisation, by reading or writing using raw
pointers.
These unsafe operations are just as susceptible to programmer errors as
their C analogues, giving rise to the bugs discussed in
\Cref{sec:eval-micro-repeat,sec:eval-micro-push}.
Capabilities can combat this by preventing out-of-bounds accesses.


\subsection{Removal of bounds checks}
\label{sec:eval-rust-bounds}

With capabilities, bounds checks can be removed altogether: instead of
the default panic, a hardware interrupt will occur with each attempted
out-of-bounds access.
Most Rust programs do not handle panics, instead crashing the program:
this is the default behaviour.
If desired, CHERI length violations can be caught and the panic handler
invoked, rather than terminating the program directly.
Therefore the CHERI mechanism is fully compatible with the existing
panicking framework.

\todo{Evidence (optimised MIPS code)}
However, most bounds checks are elided with compiler optimisations
enabled.
\Cref{sec:rust-elision} gives some situations in which bounds checks are
optimised out.
However, they are unavoidable in some situations \wip{evidence}, such as
heap-allocated linked lists or tree structures, particularly relevant
for systems programming.

\todo{Compiler likely/unlikely hints (e.g.\ panic) doesn't do anything for optimised code?}


\subsection{Safety of FFI calls}
\label{sec:eval-rust-xprocess}

\todo{As explored in CHERI-JNI, but Rust checks structs at runtime.
Discuss sealed capabilities here.}


\subsection{Leaking and circular data structures}
\todo{\url{https://doc.rust-lang.org/nomicon/leaking.html} See Rc.}


\subsection{Unsafe semantics}
Not everything is unsafe any more? Dereferencing arbitrary pointers now
guaranteed to crash rather than leak.


\section{Microbenchmarks}
\label{sec:eval-micro}

\todo{Write something here?}

\todo{Structure the microbenchmarks: cause, evidence?, lessons?/how CHERI helps}


\subsection{Pushing to a \texttt{VecDeque}: off-by-one error leads to out-of-bounds write}
\label{sec:eval-micro-push}

Rust's \texttt{VecDeque} is a circular data structure stored on a
buffer.
When this buffer is expanded, elements stored at its (former) end must
be moved to its new end.
This error was caused by incorrect use of the public capacity, accessed
by \texttt{self.capacity()}, instead of the private (raw) capacity of
the buffer, \texttt{self.cap()}.
Subsequently, the pointer to the deque's \texttt{head} would point to
the address immediately after the buffer, rather than its start.

\todo{This can be solved by not getting confused, assertion on the
copying helper (potentially slow), deque indexing instead of pointers.}


\subsection{Slice \texttt{repeat}: integer overflow leads to buffer overflow}
\label{sec:eval-micro-repeat}

This flaw arose from an unchecked write, one pattern of optimisation
using Unsafe Rust covered in \Cref{sec:rust-unsafe}.
It occurs in the \texttt{repeat} function on slices
(\Cref{lst:slice-repeat}), which returns a vector containing a slice
repeated as specified by the parameter.
Here, a buffer overflow occurs when the length of returned vector would
exceed the target's \texttt{usize}.

\begin{figure}[ht]
\begin{lstlisting}
impl<T> [T] {
    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {
        // omitted: trivial n = 0 case
        let mut buf = Vec::with_capacity(self.len() * n);

        buf.extend(self);
        {
            let mut m = n >> 1;
            while m > 0 {
                unsafe {
                    // memcpy existing elements to double the length
                }
            }
        }
        // omitted: copy into the remainder of the vector
    }
}
\end{lstlisting}
\caption{\wip{rewrite} Rust's slice \texttt{repeat}, from
\texttt{alloc::slice}. Parts omitted for brevity. This code will attempt
to write beyond the end of a buffer.
The error is in line~4; it was fixed by using a multiplication checked
against overflowing.}
\label{lst:slice-repeat}
\end{figure}

\todo{Think about this seriously. Is it at all practical? The obvious
case is the write is interrupted before the address falls of the maximum
value. Are there specific values that work for any platform?}

This is difficult to exploit, as it would require a long slice or a
large number \(n\) of repetitions, increasing the change of a
segmentation fault.
Nonetheless, it is certainly not thread-safe, and Rust does target
platforms with 16-bit \texttt{usize}, i.e.\ at most \(65,536\) elements,
making an attack plausible, if not possible.


\section{Porting safe languages to capability architectures}


\end{document}
