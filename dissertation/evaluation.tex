\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Evaluation}
\label{ch:eval}

\section{Objectives}
This project evaluates whether Rust is particularly suited to running on
CHERI.
\Cref{ch:impl} defined the scope of this evaluation, and
discussed the compromises that were made to compile Rust's core
libraries for CHERI.

The key points of this evaluation are:

\begin{itemize}
    \item What benefits does running on a CHERI architecture have for Rust?
    More concretely, how convincing are the safety and performance
    improvements as opposed to other platforms such as x86 and MIPS?
    (\Cref{sec:eval-rust})
    \item Can the safety guarantees and boundaries of unsafe code be
    changed with the use of capabilities, or: do capabilities generate
    different definitions of unsafe code?
    For example, we can guarantee that an FFI call does not change the
    contents of a buffer.
    \item What benefits do Rust programs and a compilation toolchain
    have for CHERI?
    Specifically, do borrow semantics and object lifetimes naturally
    translate to capabilities?
    Generally, are safe languages easier to port to CHERI? Do they
    derive more benefit from capabilities than unsafe languages?
    (\Cref{sec:eval-cheri})
    \item Lessons on porting a `safe' language to CHERI, or capability
    platforms in general. \wip{Wrong chapter?}
\end{itemize}


\section{Benefits to CHERI as a Rust target}
\label{sec:eval-cheri}

\subsection{Complementary safety properties}
\todo{CHERI seems to focus on spatial safety. What about revocation and
temporal safety? How helpful are Rust lifetimes and ownership?}


\subsection{Borrow semantics and object lifetimes}
\todo{Discuss provenance analysis and revocation.}


\subsection{Stricter semantics and reduced undefined behaviour}
\todo{Rust's semantics mean that programmers are less inclined to do
interesting pointer manipulations or storage, so porting might be easy.
On the other hand, CTSRD previously discovered that most C code isn't
that bad in this regard?}


\subsection{Comparable performance to C}
\todo{Faster than other managed languages. See Debian's benchmarks
comparing various languages, and note that capabilities might reduce
overheads.}


\section{Benefits to Rust from CHERI capabilities}
\label{sec:eval-rust}

\subsection{Traditional vulnerabilities in Rust}
\label{sec:eval-rust-vulns}

\todo{These are discussed in
\Cref{sec:eval-micro-repeat,sec:eval-micro-push}.}

One class of attacks that Rust aims to mitigate is buffer overflows.
In Safe Rust, bounds checks are inserted (\Cref{lst:rust-index})
to prevent out-of-bounds accesses and writes.

\begin{figure}[ht]
\begin{lstlisting}
impl<T> SliceIndex<[T]> for usize {
    #[inline]
    fn index(self, slice: &[T]) -> &T {
        // N.B., use intrinsic indexing
        &(*slice)[self]
    }
}
\end{lstlisting}
\caption{\wip{rewrite; asm} Rust's intrinsic indexing, which applies to
arrays and vectors.}
\label{lst:rust-index}
\end{figure}


\subsection{Removal of bounds checks}
Look at optimised MIPS code and performance---not much to be gained?
But: no unwind? \wip{Unwind by handling hw exception}
Compiler likely/unlikely hints (e.g.~panic) doesn't do anything for optimised code?


\subsection{Safety of FFI calls}
\todo{As explored in CHERI-JNI, but Rust checks structs at runtime.
Discuss sealed capabilities here.}


\subsection{Leaking and circular data structures}
\todo{\url{https://doc.rust-lang.org/nomicon/leaking.html} See Rc.}


\subsection{Unsafe semantics}
Not everything is unsafe any more? Dereferencing arbitrary pointers now
guaranteed to crash rather than leak.


\section{Microbenchmarks}
\label{sec:eval-micro}

\todo{Write something here?}


\subsection{Pushing to a \texttt{VecDeque}: off-by-one error leads to out-of-bounds write}
\label{sec:eval-micro-push}


\subsection{Slice \texttt{repeat}: integer overflow leads to buffer overflow}
\label{sec:eval-micro-repeat}

As \Cref{sec:rust-unsafe} discusses, checks are
sometimes omitted for performance.
An example of this is the \texttt{repeat} function on slices, which
returns a vector containing a slice repeated
(\Cref{lst:slice-repeat}).
Unfortunately, this particular optimisation contained a flaw: a buffer
overflow occurs if the length of returned vector would exceed the
target's \texttt{usize} (essentially, \texttt{size\_t}).

\begin{figure}[ht]
\begin{lstlisting}
impl<T> [T] {
    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {
        // omitted: trivial n = 0 case
        let mut buf = Vec::with_capacity(self.len() * n);

        buf.extend(self);
        {
            let mut m = n >> 1;
            while m > 0 {
                unsafe {
                    // memcpy existing elements to double the length
                }
            }
        }
        // omitted: copy into the remainder of the vector
    }
}
\end{lstlisting}
\caption{\wip{rewrite} Rust's slice \texttt{repeat}, from
\texttt{alloc::slice}. Parts omitted for brevity. This code will attempt
to write beyond the end of a buffer.}
\label{lst:slice-repeat}
\end{figure}

This is difficult to exploit, as it would require a long slice or a
large number \(n\) of repetitions, increasing the change of a
segmentation fault.
Nonetheless, it is certainly not thread-safe, and Rust does target
platforms with 16-bit \texttt{usize}, i.e.~at most \(65,536\) elements,
making an attack plausible, if not possible.
\todo{What values would work?}


\section{Porting safe languages to capability architectures}


\end{document}
