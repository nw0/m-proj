\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Evaluation}
\label{ch:eval}

\section{Objectives}
\Cref{ch:impl} defined the scope of this evaluation, and
discussed the compromises that were made to compile Rust's core
libraries for CHERI.

This chapter contains the main evaluation of CHERI capabilities in a
safe language, Rust.
An overview of the focusses of each section:

\begin{description}
    \item[\Cref{sec:eval-bugs}]
    Previous vulnerabilities in the Rust standard libraries.
    It shows that bugs in Unsafe Rust are not substantially different
    from those in C, and includes microbenchmarks demonstrating
    that CHERI capabilities provide an effective mitigation.

    \item[\Cref{sec:eval-cheri}]
    The implications of the Rust language and toolchain for CHERI.
    How Rust's guarantees complement capabilities, and why Rust is an
    ideal candidate for porting to CHERI due to its memory model and
    performance.

    \item[\Cref{sec:eval-rust,sec:eval-sealing,sec:eval-rust-xprocess}]
    The implications of CHERI capabilities on the Rust language.
    How Rust's guarantees can be enforced even in Unsafe Rust, and
    extended to cover cross-domain function calls, without changing
    language semantics.

    \item[\Cref{sec:eval-betterunsafe}]
    The connection between Unsafe Rust and undefined behaviour,
    referring to underlying assumptions in the language.
    How CHERI capabilities rule out forms of undefined behaviour in
    Rust, by guaranteeing a hardware exception on violation.

    \item[\Cref{sec:eval-hybrid}]
    A method to minimise the memory overheads of capability protection by
    using the hybrid ABI, which allows both capability and
    non-capability pointers in a single program.
    A consideration of the conditions that allow this and the guarantees
    it provides.

    \item[\Cref{sec:eval-usize}]
    An argument for reinterpreting the previously-discussed
    \texttt{usize} definition, with respect to its usage in the
    language.
    Reference is made to community consensus, existing definitions, and
    types in other languages.

    \item[\Cref{sec:eval-porting}]
    General concerns and implications when introducing capabilities to
    safe languages; when they benefit the most and least.

    \item[\Cref{sec:eval-summary}] Chapter summary.
\end{description}


\section{Errors leading to memory violations in Rust}
\label{sec:eval-bugs}

Despite Rust's attention to safe language design, programmer error is
still a rich source of potential vulnerabilities.
While the Rust community is generally conscious about memory safety and
security, nowhere is this more true than with the language and compiler
developers.

This section covers four entirely unrelated memory safety flaws
discovered in the Rust standard library, all preventable with CHERI
capabilities.
Where relevant, demonstrative microbenchmarks were performed on either
CheriBSD on Qemu-CHERI with 128-bit capability pointers, or FreeBSD~11.2
(amd64) for the non-capability comparison.
In all cases, the Rust compiler was as described in
\Cref{ch:rust,ch:impl}, specifying the target as appropriate.


\subsection{Pushing to a \texttt{VecDeque}: off-by-one error leads to out-of-bounds write}
\label{sec:eval-micro-push}

\subsubsection{Cause}
Rust's \texttt{VecDeque} is a circular data structure stored on a
buffer.
When this buffer is expanded, elements stored at its (former) end must
be moved to its new end.
This error was caused by incorrectly using the public capacity, accessed
by \texttt{self.capacity()}, instead of the private (raw) capacity of
the buffer, \texttt{self.cap()}
(\Cref{lst:deque-defs})~\cite{rust-pr-reserve,rust-issue-deque-append}.

\begin{figure}[ht]
    \lstinputlisting{listings/deque-defs.rs}
    \caption{
        The public-facing definitions for a \texttt{VecDeque}'s
        capacity, and pushing to the end.
        It will not escape the reader's attention that the
        \texttt{capacity()} might be mistaken for the \texttt{cap()}, a
        likely cause of this error.
        These definitions are current in Rust.
        \texttt{push\_back} annotated with implicit precondition.
    }
    \label{lst:deque-defs}
\end{figure}

Subsequently, the pointer to the deque's \texttt{head} would point to
the address immediately after the buffer, rather than its start.
Pushing to the back of the deque then attempts to write to the address
after the buffer, rather than within it.

This appears to have been caused by the similarity of the method names
leading to an off-by-one error.

\subsubsection{Demonstration microbenchmark}
I checked that this spatial violation is caught by CHERI capabilities,
but is not detected on x86 FreeBSD.
Sample code is shown in \Cref{lst:micro-capacity}.

\begin{figure}[ht]
    \lstinputlisting{listings/micro-capacity.rs}
    \caption{
        A program which writes beyond the end of an allocated
        \texttt{VecDeque} buffer.
        An off-by-one error in \texttt{reserve} results in an unsound
        call another function, updating \texttt{head} to 32.
        Under x86 without capabilities, the program terminates normally,
        printing output as shown in the
        comments.{\protect\textsuperscript\textdagger}
        With CHERI capabilities, execution continues until line~12, which
        traps due to a length violation.
        \\ {\footnotesize \protect\textdagger\ The \texttt{prntf!} macro
        is \emph{not} built-in; I define it for convenience. Using the
        same syntax as the C \texttt{printf} function, it avoids
        considerable unsafe boilerplate while enhancing readability.}
    }
    \label{lst:micro-capacity}
\end{figure}

Had another data structure been allocated after the deque, its start
would have been overwritten by the pushed element.
However, I was unable to force this situation without modifying the
allocator for the purpose.

\subsubsection{Observations}
This scenario is a plain example of a bounds violation that is
prevented by capabilities.
Had the underlying implementation not used an unchecked write (line 12
of \Cref{lst:deque-defs}), this would also have been prevented by Rust's
bounds checks, as the \texttt{VecDeque} is backed by a vector.
This is an interesting lesson: bounds checks are useful not only for the
end-programmer, but also (presumably meticulous) language developers.

Note that whether this exceeds the bounds is implementation specific!
The existing implementation will reserve space for 32 elements here, but
if more space had been reserved by \texttt{with\_capacity} or its
underlying code (e.g.\ 64 elements), the object bounds would have been
correspondingly wider.
In that case, it would only be detected if the value was written using
the built-in bounds-checking indexing, although the pushed value would
still disappear.


\subsection{Slice \texttt{repeat}: integer overflow leads to buffer overflow}
\label{sec:eval-micro-repeat}

\subsubsection{Cause}
This flaw arose from an unchecked write, one pattern of optimisation
using Unsafe Rust covered in \Cref{sec:rust-unsafe}.
It occurs in the \texttt{repeat} function on slices
(\Cref{lst:slice-repeat}), which returns a vector containing a slice
repeated as specified by the parameter.
Here, a buffer overflow occurs when the length of returned vector would
overflow the target's \texttt{usize}.

\begin{figure}[ht]
    \lstinputlisting{listings/slice-repeat.rs}
    \caption{
        Rust's slice \texttt{repeat}, from \texttt{alloc::slice}.
        Parts omitted for brevity.
        This code attempts to write beyond the end of a buffer.
        The error is in line~5; it was fixed by checking the
        multiplication against integer overflow.
    }
    \label{lst:slice-repeat}
\end{figure}

This appears to be a simple integer overflow translating to a buffer
overflow.
Note that this overflow will be caught when compiling Rust code in debug
mode, as integer overflow checks will apply to all arithmetic; release
mode instead uses two's complement and is \emph{not} undefined.

\subsubsection{Demonstration microbenchmark}
I did not demonstrate this by calling the \texttt{repeat} method as
given: as noted below, attempting to copy more than \(2^{64}\) elements
is difficult to do in a controlled way.
Instead, \Cref{lst:micro-repeat} shows the code used to demonstrate the
effects of this bug.

\begin{figure}[htp]
    \lstinputlisting{listings/micro-repeat.rs}
    \caption{
        Demonstration of how an integer overflow can lead to a buffer
        overflow when repeating a slice.
        Three iterations of the copy are performed (lines 20--31) to
        ensure \texttt{v} is overwritten on the non-capability machine;
        with capabilities this traps on the first iteration.
    }
    \label{lst:micro-repeat}
\end{figure}

I chose values carefully to demonstrate the overflow on the test
machine; other values may work depending on the operating system and
allocator.

\subsubsection{Observations}
This is difficult to exploit, as it would require a long slice or a
large number \(n\) of repetitions, increasing the chance of a
segmentation fault.
An exploit would probably have to interrupt the write before too many
iterations of the loop, and either spawn a new process or stop the
thread executing this loop before the operating system stopped it.


\subsection{Out-of-bounds indexing into a reversed slice}

\subsubsection{Cause}
An unhandled unsigned integer wrap-around could lead to out-of-bounds
slice indexing through its reverse iterator~\cite{rust-pr-reverse}.
\Cref{lst:bug-reverse} shows the relevant implementation, defined in the
core library.

In this situation, the assumptions about the underlying iterator
implementation are not obvious, and thus not considered when writing
this method.

\begin{figure}[htp]
    \lstinputlisting{listings/bug-reverse.rs}
    \caption{
        Previous implementation of indexing into a reversed slice.
        If \texttt{amt - index - 1 < 0}, the index wraps, attempting to
        access an index larger than the indexable region.
        This may be unsafe depending on the underlying implementation.
        This was fixed by checking that \texttt{amt > index} before
        indexing, returning \texttt{None}
        otherwise~\cite{rust-commit-reverse}.
    }
    \label{lst:bug-reverse}
\end{figure}

\subsubsection{Observations}
A very large index (i.e.\ close to \texttt{usize::MAX}) could be passed
to the reverse indexing function to get values slightly beyond the end
of the slice.
As `slice' suggests, they frequently represent a view into a larger
slice, so this could reasonably be expected to be defined.

Whether this is possible is implementation-dependent; if the
reverse \texttt{idx} is expected to handle bad values, then the
underlying \texttt{idx} should arguably also handle them.
If anything, this example  and its resolution is an example of the
safety awareness of Rust developers, rather than a fundamental bug.


\subsection{Iterator method violates Rust's uniqueness of shared references}
\label{sec:eval-bug-vec-mut}

\subsubsection{Cause}
An iterator method in the core library should return a mutable slice
from a mutable iterator.
Instead, it returns a mutable slice for any iterator.
\Cref{lst:bug-mutslice} shows that it does this by calling an unsafe
method which operates on raw pointers~\cite{rust-issue-vec-mut}.

\begin{figure}[ht]
    \lstinputlisting{listings/bug-as_mut_slice.rs}
    \caption{
        Built-in method returning a mutable slice for a (mutable)
        iterator: except it accepts immutable iterators also.
        This violates Rust's temporal guarantee that mutable references
        are never shared.
    }
    \label{lst:bug-mutslice}
\end{figure}

This bug appears to be caused by copying and pasting the Iterator
\texttt{as\_slice} method when writing \texttt{as\_mut\_slice}.
A demonstration of the fallibility of programmers and motivator for safe
syntax, neither the language nor the runtime helps in this situation.

\subsubsection{Observations}
This is a clear violation of one of Rust's temporal safety guarantees,
that mutable references must not ordinarily be shared.
While this is not strictly undefined behaviour, attempting to mutate the
returned object is, defeating the point of getting a mutable slice.

Though this error leads to temporal unsafety, this could be prevented by
passing a read-only capability for an immutable borrow.
\Cref{sec:eval-rust-enforce-immut} discusses this in more detail.


\section{Implications of Rust semantics for CHERI targets}
\label{sec:eval-cheri}

Capabilities are typically seen as a mechanism to improve the security
of languages and runtimes.
It is therefore slightly unusual to consider how a language might
improve capabilities.
Nevertheless, this section considers how Rust complements CHERI
capabilities, presenting a contrast to other safe languages.

\subsection{Ownership gives complementary temporal safety}
\label{sec:eval-cheri-spatial-temporal}

One of Rust's main objectives and early selling points was
\emph{fearless concurrency}.
It uses its ownership model and type system to manage temporal memory
safety~\cite{rust-trpl-book}.
These mechanisms prevent dangling pointers or use-after-free in Safe
Rust (\Cref{sec:rust-borrow}), although the use of raw pointers in
Unsafe Rust can bypass these checks.

By contrast, CHERI's initial focus was on spatial integrity, only later
moving to consider temporal safety by means of tagging.
Temporal safety is provided by marking capabilities as \emph{local} or
\emph{global}, which restricts the flow of capabilities and thereby
preventing their leakage~\cite{cheri2015}.

However, this provision only yields atomic pointer updates and
identifiability of pointers;
it is not precise enough to guarantee safety across thread or process
boundaries, such as foreign function interface (FFI) and system
calls~\cite{cheri-2019-abstract}.
While Rust does not provide temporal protection against other processes
misusing its resources, its ownership model guarantees that a thread
which has yielded a resource does not attempt to modify it while it has
been lent out.
Likewise, the ownership model prevents similar conflicts within a
concurrent Rust program, complementing CHERI's spatial integrity.

Note: \Cref{sec:eval-rust-xprocess} discusses how CHERI capabilities can
be used to make Rust's FFI or cross-process calls safer.

\subsubsection{Temporal safety under CHERI}
While not inherent to capability systems, CHERI enables a form of
revocation, preventing dangling pointers from being dereferenced.
See \Cref{sec:eval-rust-use-after-free} for an example of how revocation
can be useful in Rust.


\subsection{Stronger pointer provenance model in Rust}
\label{sec:eval-cheri-provenance}

With a fully-functional Rust compiler for CHERI, porting Rust programs
and crates should be straightforward.
In particular, common compatibility issues in CHERI due to pointer
provenance~\cite{cheri-2019-abstract} do not apply in Safe Rust,
as the compiler tracks object ownership comprehensively.\footnote{
An exception is `pointer shape'; see \Cref{sec:impl-width}.
}

Due to Rust's lack of a specification and documented undefined
behaviour, programmers are discouraged from performing such
capability-incompatible pointer manipulation.
It is unclear if problematic pointer manipulation is currently
undefined in Rust, but community discussions suggest that it might be in
future~\cite{rust-ucg-provenance}.
As such, unsafe code should not rely on patterns that break provenance
analysis in these ways.\footnote{
For example, the XOR linked list \emph{might} not be implementable
in Rust without exhibiting undefined behaviour.
}


\subsection{Safer code patterns yields easier porting to CHERI}
\label{sec:eval-cheri-port}

Rust has been designed to guide programmers toward writing safe code,
and to highlight potentially dangerous operations.
Programmers have less cause to perform unusual or \emph{clever} pointer
manipulation, writing code that does not immediately compile for CHERI.
\Cref{sec:impl-div-lib} documented the limited incompatibilities in the
core library; most changes affect the compiler.

Nevertheless, one should recognise that the difficulty of porting C
programs to capability architectures and CHERI in particular is not
thought to be too onerous~\cite{capsicum-usability}.
This must be weighed against the prospect of updating the Rust compiler.


\subsection{Comparable performance to C}
\label{sec:eval-cheri-perf}

While Rust possesses strong safety features, it also provides good
performance.
For this reason, it has garnered attention in applications as diverse as
astrophysics (favourable comparison to Fortran~\cite{blanco-astro}), GPU
programming (comparable to handwritten and domain-specific language
generated OpenCL~\cite{holk-gpu}), and garbage collection (comparable to
C~\cite{lin-gc}).
The Debian project maintains a set of toy benchmarks run against
user-submitted programs in diverse
languages~\cite{debian-benchmarksgame}, showing that Rust performs as
well as C and C++ under their testing problems and environment.
All three come well ahead of the next `safe' languages, Java and Go.

These suggest that Rust is capable of matching C under some
circumstances while being safer, making it a good choice in general.
If CHERI implementers are keen on augmenting hardware safety features
with a speedy, low-runtime language, then Rust makes a sensible choice,
especially for embedded platforms.


\subsection{Larger pointer size can be offset by removing redundant bounds information}
\label{sec:eval-cheri-memfoot}

Currently, any memory slice stores a pointer to the relevant
object and its length~\cite{blandy-orendorff}.
As bounds information can be derived from a CHERI capability pointer, it
is redundant to store the length.
Instead, a \texttt{CGetLen} instruction could retrieve the bounds
information when needed.
The overhead of a 128-bit pointer can therefore be offset by the removal
of a 64-bit length variable, negating the memory overhead for slices
which would apply in other languages.

\subsubsection{Impact on data structures}
Associating bounds information with pointers is a natural pattern for
slices, which have one fixed bound.
However, vectors have different bounds for the allocated space and the
initialised indices.
Currently, these are known as the \emph{capacity} and \emph{length} of
the vector respectively.
This tension can be resolved in two ways, both requiring capability
pointers to the allocation\footnote{
Monotonicity implies that the full allocated space must be continuously
pointed to; otherwise it is leaked.
}:

\begin{description}
    \item[Initialised length variable] This is similar to the current
    implementation, where the capacity variable can be dropped.
    This saves space, as a length variable would be a \texttt{usize} (64
    bits), where a capability would be 128 bits.
    However, bounds checks will be required for indexing into vectors,
    hence could not be completely removed from Rust compilation (to
    CHERI).
    \item[Slice capability pointer] A natural solution: this squares
    with Rust's type system, where indexing is provided by the
    \texttt{SliceIndex} trait implemented for slices.
    However this requires more space, and it is unclear if deriving a
    new slice capability for each push/pop operation on the vector will
    be faster or slower than updating a length variable.
    This should not affect concurrency when popping as CHERI
    capabilities support atomic operations: pushing would require the
    slice capability to be derived from the allocation capability, which
    could pose a problem.
\end{description}

\subsubsection{Memory overhead of CHERI capabilities}
The memory traffic overheads of CHERI capabilities for diverse C
benchmark programs is within 5--10\%~\cite{cheri-tagged-memory}, with
the greatest impact on pointer-heavy workloads.
In Rust, some overhead will still apply: capability pointers are always
larger, and bounds checks are only occasionally saved.
The impact on cache usage is unclear, but it is not unreasonable to
suggest that overheads will be at most as large as under equivalent C
workloads.
\Cref{sec:eval-hybrid} outlines a strategy to reduce the memory
impact of CHERI capabilities in Rust.


\section{Spatial integrity in Rust from CHERI capabilities}
\label{sec:eval-rust}

This section explores how memory safety can be improved in the Rust
compiler and runtime by introducing CHERI capabilities.
\Cref{sec:eval-betterunsafe} instead considers how capabilities can be
used to reduce the danger posed by undefined behaviour, enabling changes
to the semantics of the language.

\subsection{Mitigation of traditional vulnerabilities}
\label{sec:eval-rust-vulns}

One class of attacks that Rust aims to mitigate is buffer overflows.
In Safe Rust, bounds checks are inserted (\Cref{sec:bg-rust-bounds})
to prevent out-of-bounds accesses and writes.

Nevertheless, as \Cref{sec:rust-unsafe} highlights, unchecked accesses
are sometimes used for optimisation, by reading or writing using raw
pointers.
These unsafe operations are just as susceptible to programmer errors as
their C analogues, giving rise to the bugs discussed in
\Cref{sec:eval-micro-repeat,sec:eval-micro-push}.
Capabilities can combat this by preventing out-of-bounds accesses.


\subsection{Bounds checks removal}
\label{sec:eval-rust-bounds}

With capabilities, bounds checks can be removed altogether: instead of
the default panic, a hardware interrupt will occur with each attempted
out-of-bounds access.
Most Rust programs do not handle panics, instead crashing the program:
this is the default behaviour.
If desired, CHERI length violations can be caught and the panic handler
invoked, rather than terminating the program directly.
Therefore the CHERI mechanism is fully compatible with the existing
panicking framework.

This is a low-impact improvement, as most bounds checks are elided with
compiler optimisations enabled; see \Cref{sec:rust-elision} for examples
where checks are already optimised.
However, they are unavoidable in some situations, such as random array
accesses.


\subsection{Sub-object bound enforcement}

In Rust, \emph{slices} can be created from continuous segments of an
iterable.
Slices can be passed to functions, only allowing them to refer to part
of an array, or a \emph{subslice}.
Using pointer manipulation, such a function could access indices of the
array which are not part of the slice.
This is not undefined behaviour as the pointer would point to a valid
part of the object, although it must be done in Unsafe Rust.

With CHERI capabilities, a subslice could be passed as a pointer with
bounds restricted to the relevant segment of the array.
It would then be impossible for a function to access the other elements
unexpectedly, again enforcing the principle of least privilege.
Additionally, this can enforce Rust's temporal protection when splitting
slices with the \texttt{split\_at\_mut} method.

Likewise, this can apply to struct members, generalising the protection
to objects with known continuous layouts.
The cost of doing this is similar to that of enforcing immutability in
\Cref{sec:eval-rust-enforce-immut}.


\subsection{Use-after-free elimination in Safe Rust}
\label{sec:eval-rust-use-after-free}

As we have discovered, spatial integrity is not an absolute guarantee in
Rust.
Unsurprisingly, neither is temporal safety, even in \emph{Safe} Rust!

Consider the following example from the documentation, a simplified
version of the reference-counted container type, \texttt{Rc}, and its
simplified \texttt{Drop} implementation (\Cref{lst:eval-rust-rc-drop}).
By overflowing the reference count (using \texttt{mem::forget} if memory
usage is an issue), one can cause the pointed-to object to be
deallocated, even with outstanding references, defeating the reference
counter.
This creates a use-after-free bug~\cite{rust-nomicon-rc-leak}.

\begin{figure}[ht]
    \lstinputlisting{listings/rc-drop.rs}
    \caption{
        A potential use-after-free bug, if \texttt{ref\_count}
        overflows.
        This may occur in Safe Rust, as \texttt{drop} methods are always
        safe: the unsafety is encapsulated here, and also in
        \texttt{mem::forget}, which would be used to overflow the count.
        Example from the Rust documentation~\cite{rust-nomicon-rc-leak}.
    }
    \label{lst:eval-rust-rc-drop}
\end{figure}

This can be resolved by revocation, for which CHERI capabilities provide
a foundation by virtue of monotonicity and memory tagging.
Revocation prevents programs from reading or modifying memory which
has been deallocated, or more importantly reallocated, another common
source of vulnerabilities.
Note that there are performance overheads associated with
revocation~\cite{cheri-v6}, and Rust's temporal guarantees mean that its
utility is largely constrained to unsafe code.
This is discussed further in \Cref{sec:eval-betterunsafe-reasons}.


\section{Capability sealing to protect Rust objects}
\label{sec:eval-sealing}

\emph{Capability sealing} can prevent a capability from being used to
mutate or dereference the memory it refers to, as described in
\Cref{sec:bg-cheri-sealing}.
This section describes how the Rust runtime can use this mechanism to
enforce program invariants.

\subsection{Preserving object immutability in Unsafe Rust}
\label{sec:eval-rust-enforce-immut}

Modifying an immutable object is undefined behaviour in Rust, and should
be prevented by the compiler in Safe Rust.
The only exception to this pattern is the \texttt{UnsafeCell},
modifications to which are explicitly excluded from being undefined
behaviour.
There, the programmer is expected to implement an object safely without
causing concurrency bugs.

However, the compiler does not prevent this invariant from being
violated in Unsafe Rust, where the programmer can essentially bypass the
type system by casting raw pointers.
There have been bugs in the standard library~\cite{rust-issue-vec-mut}
(\Cref{sec:eval-bug-vec-mut}) resulting in mutable references to
supposedly immutable objects.

Since mutating these is undefined, it is reasonable to protect them
from being written to, which can be accomplished with capabilities.
This enforces the principle of least privilege on shared references.
Sealing can be used to prevent mutation.

\subsubsection{Note on differences from C}
Enforcing C's \texttt{const} in hardware proved problematic for CHERI in
the past, due to functions like~\texttt{strchr} (C), which derive a
non-\texttt{const} (mutable) pointer from an immutable
one~\cite{cheri-prog-guide}.

\begin{lstlisting}[language=C,numbers=none]
char *strchr(const char *s, int c);
\end{lstlisting}

The proposal of deriving a read-only capability for each immutable
reference in Rust does not suffer this problem, as it is not possible to
derive a mutable reference from an immutable one.
Indeed, this idiom does not occur in Rust as immutability is conveyed by
the function signature.


\subsection{Preserving object immutability across FFI boundaries}
No amount of type-checking can prevent a foreign function from modifying
a supposedly immutable borrowed object, since they use raw pointers and
are not bound to Rust's semantics.

By passing a capability without write permissions to a function, this
particular cause of undefined behaviour can be eliminated.
This supports the use of \emph{least privilege} even across foreign
function interfaces.


\subsection{Protecting data from callback functions}
Another situation that benefits from least privilege are callbacks from
FFI code.
In this scenario, an FFI function might receive a pointer to data it is
expected not to access, but instead merely to return the pointer to the
original process at the correct time.

This can be enforced through capability sealing.
The foreign function would be unable to dereference the object, but the
capability could be unsealed by the original program to regain access to
the original data~\cite{cheri-v6}.
This allows less trusted code to handle Rust objects while still
guaranteeing integrity and confidentiality.


\subsection{Fine-grained object protection}
\label{sec:eval-capability-using-type}

As an extension of the previous sections, not only can specific objects
passed across unsafe or FFI boundaries be protected, but also objects
transitively accessed via those objects.
CHERI capabilities include an \emph{object type} field, on which sealing
and unsealing can be predicated; this can be used to protect a
`confidential object' type (and derivable types) from abuse by Unsafe
Rust or FFI functions.
This can easily be marked using a Rust trait.

To motivate this protection, consider a library written in Safe Rust.
Its authors may wish to restrict the ability of other code to abuse
Unsafe Rust to read its data, for instance to protect customer records.
Capability sealing presents a viable method to enforce this.

Note that accessing an object which one has a reference to is not
undefined.
Sealing to prevent pointer dereferences can therefore be used to enforce
invariants which other code may not conform to.
For instance, a high-performance data structure might attempt a deep
copy of its objects, which would be obstructed by sealing in the
scenario above.


\subsection{Efficacy and costs of sealing}
However, manipulating capabilities is not free and the overheads of
manipulating capabilities should be weighed against enforcement within
the existing type system, which is statically enforced but does not
protect against unsafe code.
Additionally, this does not solve the inherent potential for programmer
error in the compiler, such as incorrectly failing to seal a capability.


\section{Improved safety of FFI calls}
\label{sec:eval-rust-xprocess}

A quick survey of Rust crates that use FFI bindings shows that most of
them deal with some form of low-level behaviour, including encryption,
memory allocation, USB interfaces, and filesystem mounts.\footnote{
    Rust crates are published libraries.
    A survey of the ``Rust package registry'' may be of interest:
    \url{https://crates.io/search?q=-sys};
    a \texttt{-sys} suffix conventionally denotes an FFI crate.
}
With performance or low-level access as the primary goal of most Rust
FFI calls, safety may not be a major concern, even if it could allow
arbitrary code execution in the Rust
program~\cite{szekeres-eternal-war}.

Most of the discussion below has to do with object capabilities and is
thus inherent in the use of CHERI capabilities, but system call
protection is a separate feature of CHERI compartmentalisation.
Watson et al.\ describe the mechanism and security implications with
regard to C~\cite{cheri2015}.
Many of the points apply to non-FFI code as well, although protection
across domain boundaries is perhaps more significant as FFI calls cannot
be type- or borrow-checked.

\subsection{Prevention of use-after-free from FFI}
The use of FFI functions can bypass Rust's object lifetime model, as
there is no way to ensure that an FFI function has not stored or leaked
references to borrowed Rust objects.
This can lead to later temporal unsoundness in the Rust program.

While this cannot be completely prevented with capabilities as-is,
\Cref{sec:eval-betterunsafe-reasons} discusses the possibility of using
revocations to manage this risk.

\subsection{Enforcement of object boundaries}
Objects can only be passed to C as raw pointers.
As such, a buffer overflow through an FFI function is no more difficult
than in C natively, and no less serious.

A simple example of an overflow is a C string with a missing NUL
terminating byte.
To overcome this, Rust strings instead store a length value and a byte
array, making them non-interchangeable with C strings.
However, if a programmer neglects to convert between
the formats, passing a Rust string to a C function will quickly lead to
an overflow.

Object capabilities easily protect against this by storing and enforcing
object bounds.
Importantly, they protect the rest of the calling program's address
space, preventing a cross-domain call from accessing data which was not
explicitly passed to it.

\subsection{Protection of system calls}
In addition to protecting the caller's memory, CHERI can be extended to
protect access to system calls in FFI functions.
This is achieved by funnelling system calls through classes which only
permit safe calls~\cite{cheri2015}.
A caller can thereby restrict the privileges of a callee function,
preventing bugs in called libraries from propagating to the host
program.


\section{Strengthening unsafety}
\label{sec:eval-betterunsafe}

This section considers the danger posed by undefined behaviour in Rust,
and how it can be mitigated by CHERI capabilities, enhancing the
semantics and guarantees of the language while not impeding compiler
transformations and optimisation.

I address four of the nine forms of undefined behaviour documented by
the Rust project, and show how they are made safer with capabilities.

\subsection{Rationale for Unsafe Rust}
In Safe Rust, the compiler accepts programs which avoid memory safety
problems using its type- and borrow-checkers.
Unsafe Rust enables programs which would not otherwise pass this static
analysis~\cite{rust-trpl-book}.

Programmers bypass these checks by using raw pointers, unsafe traits, or
using mutable static variables, all of which could violate temporal
memory safety.
Reaching undefined behaviour is possible with unsafe code, where it is
not supposed to be possible in Safe Rust.


\subsection{From unsafe code to undefined behaviour}
A requirement of the Rust language is that safe code should \emph{never}
be able to exhibit undefined behaviour: unsafe code must be handled
thoroughly such that safe functions are defined on all inputs.
Thus Unsafe Rust and undefined behaviour are inextricably linked.

Undefined behaviour in Rust is fairly simple to comprehend:
the core list contains only 9 points~\cite{rust-ref},\footnote{
\emph{The list is non-exhaustive.} Note: Rust has no formal
semantics or specification, making the idea of particular undefined
behaviours rather arbitrary.}
none of which are challenging to avoid, unlike signed integer overflow
in C.
The following sections show how the CHERI architecture can be used to
restrict undefined behaviour, and thereby make Unsafe Rust safer.


\subsection{Restricting undefined behaviour with CHERI capabilities}
\label{sec:eval-betterunsafe-reasons}

The undefined behaviour below takes the form of invariants assumed by
the Rust compiler or LLVM; they all involve the usage of pointers or
references.
Transformations based on these assumptions are made safer, by
guaranteeing a trap if the invariant is violated.

\subsubsection{LLVM pointer aliasing rules}
Breaking LLVM's pointer aliasing rules is forbidden.
In essence, the rules state that a pointer may not be used to access
memory apart from those addresses it is based on.

CHERI capabilities rule this out, due to monotonicity.
In fact, they impose stronger conditions, as a capability formed by an
\texttt{inttoptr} cannot be dereferenced.

\subsubsection{Mutation of non-mutable data}
CHERI capabilities can prevent the mutation of data reached through a
shared reference by enforcing object immutability as detailed in
\Cref{sec:eval-rust-enforce-immut}.
In this case, the references are known to be immutable in Rust
semantics, so this is easy to compile and enforce.

\subsubsection{Enforcement of the \texttt{noalias} model}
Likewise, CHERI capabilities can rule out violations of LLVM's
\texttt{noalias} model in Rust by similar means.
To check this, first note that the model will not be violated in Safe
Rust, as the compiler enforces uniqueness of mutable references.
It is thus only necessary to prevent the mutation of an object through a
reference if other references to that object are being used.

This can be done by deriving a read-only capability for immutable
references.
As the compiler enforces the uniqueness of mutable references, the two
measures combined prevent violations of this model in unsafe code.

\paragraph{Caveat}
A mutable reference can first be converted to a raw pointer, and
subsequently duplicated in unsafe code.
This would prevent the Rust compiler from enforcing the uniqueness of
mutable references or generating non-writeable capabilities, abandoning
Rust's temporal safety guarantees.

\subsubsection{Dereferencing null or dangling pointers}
This invariant is traditionally used to show that a pointer is not
null or dangling, if it has been previously dereferenced.
That is to say a pointer which has already been dereferenced is safe to
dereference again, which ties in with the aliasing rules discussed
above.
It is then considered safe to optimise away null
checks~\cite{wang2013towards,llvm-undef-dce}, possibly causing an
invalid dereference.

While capabilities cannot prevent an attempt to dereference a pointer,
they can prevent dereferences from succeeding.
For instance, a null pointer or an arbitrarily-constructed pointer from
\texttt{inttoptr} will fail to dereference on CHERI, as it would not
possess a valid capability.
This removes much of the danger from dereferencing a null or dangling
pointer, by guaranteeing that it will trap rather than compromising the
integrity or confidentiality of memory.

\paragraph{Dangling pointers}
By themselves, capabilities do not offer protection against
dereferencing a dangling pointer, as they derive from a previously-valid
object.
However, revocation allows dangling pointers to be identified and
marked, preventing them from being used.


\section{Hybrid ABI: Minimising the memory footprint of CHERI capabilities}
\label{sec:eval-hybrid}

\subsection{Safe Rust is memory safe}
Observe that the bugs covered in \Cref{sec:eval-bugs} occur in Unsafe
Rust: either from the exposure of unsafe methods as safe, thereby
failing to handle all the cases, or through errors in the unsafe code
itself.
This is no coincidence: Safe Rust is not expressive enough to generate
memory safety errors, as it lacks the memory manipulation primitives to
do so.
This is evinced by the additional actions programmers may take in Unsafe
Rust~\cite{rust-nomicon-safe-unsafe}.

Being satisfied that Safe Rust is indeed memory safe, references that
are only manipulated in Safe Rust need not be protected by capabilities,
reducing the overall memory overhead.


\subsection{Pointer provenance for Unsafe Rust}
Due to Rust's strong provenance model, all references can be traced to
their original object, and so can raw pointers generated from that
object.
Thus all references used in Unsafe Rust can be tracked to their
instantiation at compile time, and marked to indicate that a capability
pointer should be used.
Unsafe Rust code would therefore only encounter capability pointers.

Likewise, this analysis can determine all objects reached from unsafe
code: similar analysis is already performed to prevent modifying
immutable objects in Unsafe Rust.\footnote{
For completeness, unsafe code can modify immutable objects by casting to
(Rust) raw pointers.
The provenance of these raw pointers is still tracked by the compiler;
see Stacked Borrows for an effort using provenance to enforce semantics
on Unsafe Rust~\cite{rust-stacked-borrows}.
}

Note that raw pointers can be manipulated to point to a different
object, even if this is undefined behaviour in Rust.
However, if each raw pointer is a capability pointer, such code will
still be unable to violate memory safety.


\subsection{Reduction in memory overhead of capabilities}
Such a scheme would use non-capability pointers in the default LLVM
address space for memory only accessed by Safe Rust code.
This results in reduction in the memory overhead of capabilities, due to
the use of ordinary pointers; the overhead being constrained to objects
that are manipulated in unsafe code.
This is possible using the hybrid ABI, rather than the pure capability
ABI implemented in this project.

Note that Rust is considered to be similarly performant to C
(\Cref{sec:eval-cheri-perf}).
However, C lacks a separation of `safe' and `unsafe' code, and hence
lacks a practical mechanism to distinguish low-risk code, making this
optimisation impossible.
It is possible to focus on dangerous libraries, traditionally those
providing high-performance data parsing, and only use capabilities
there.
Nevertheless, this ignores the fact that serious vulnerabilities in C code
have been unexpectedly found in otherwise safe-looking code, sometimes
due to the subtleties of the C standard~\cite{memarian2016cdepths}.
Consequently, capability protection could be optimised for a lower
footprint on Rust code than C, potentially making it the ideal language
for a CHERI platform.


\subsection{Limitations}
Optimisation opportunity could be limited, however.
Many routines in the core library use unsafe code to manipulate objects,
such as the built-in sorting algorithms.
It is unclear how many routines do this to avoid bounds-checked
accesses, as is the sole reason in sorting: recall that runtime bounds
checking is redundant in CHERI, but only with the use of capabilities.

A study of the proportion of Rust references not used in unsafe code is
therefore advisable.
Note that not all references passed to Unsafe Rust need to be marked:
only usage for raw pointer operations and FFI calls are relevant in this
case, along with specific compiler primitives.


\section{Distinguishing pointer width and index sizes}
\label{sec:eval-usize}

\Cref{sec:rust-usize,sec:impl-width} discussed the implications of
Rust's implementation of index size or \texttt{usize} in the compiler.
Here I consider how its definition could be changed or reinterpreted to
make it compatible with CHERI.

\subsection{Definition of \texttt{usize}}
The \texttt{usize} type is classified as a `machine-dependent integer
type'.
It is an \emph{unsigned integer type with the same number of bits as the
platform's pointer type, which can represent every memory address in the
process}~\cite{rust-ref}.
Elsewhere, the Rust documentation states that it is \emph{the
pointer-sized integer type}, and that \emph{the size of this primitive
is how many bytes it takes to reference any location in memory}, stating
that it is 8 bytes on a 64-bit target~\cite{rust-std-primitive-usize}.

Likewise, the \texttt{isize} is defined as its signed counterpart.
The Rust reference notes that the \emph{theoretical upper bound on
object and array size is the maximum \texttt{isize} value}, even though
the \texttt{usize} type is used for indexing into slices.

\subsection{Representing every memory address}
There is no pair of morphisms that translate between integers (including
the \texttt{usize}) and CHERI capabilities.
This is due to monotonicity, where integers cannot be transformed into
pointers, and enforced by the memory tagging mechanism.
Thus no memory address can be recovered solely from an integer.

Notwithstanding the difference between \emph{represent} and
\emph{reference}, and the existence of arbitrary pointer values, it
seems clear that there should be some sort of correspondence between
pointers and \texttt{usize} values.
Specifically, the text suggests that this correspondence is between
\emph{memory addresses} or \emph{locations}, rather than any data
associated with a pointer.

\subsubsection{Usage in the compiler and core library}
This correspondence is echoed in compiler usage and the core library.
Usages of \texttt{usize} are not concerned with tag information that may
be associated with a pointer; they refer to sizes, ranges, and
distances.

For instance, the 8 tag bits provided on the AArch64 architecture are of
no interest when using a \texttt{usize}.


\subsection{Rust context}
This is a complex issue in Rust.
Rust RFC \#544~\cite{rust-rfc-isize} is ostensibly a naming issue for
this pointer-sized integer type, but it provides an excellent background
to the semantics and usage of this type in Rust.
Indeed, its complexity is such that the community understands
\texttt{usize} to be ``the size of a pointer by definition.'', or
``defined\ldots[to be] the same size as *const ()'', i.e.\ a raw
pointer.
A more cautious opinion gave that ``traditionally,
\texttt{usize == uintptr\_t}''.\footnote{
Responses in clarification of the definition of \texttt{usize}, from the
Rust compiler forum on Zulip.
The query included the CHERI example, where 64 bits of a 128-bit pointer
are used for addressing.
}

Despite these statements, I claim that the text of the definitions and
the usage show that the \texttt{usize} need only be large enough to
reference memory addresses.
Thus 48 bits suffice on CHERI, though 64 might be a more practical
value.

This is something of a controversial issue in Rust, and even a seemingly
minor clarification may take considerable time to make it into the
documentation.
From a semantic standpoint, however, to use a 128-bit \texttt{usize} on
CHERI128 would be not only inconvenient, but incorrect.


\subsection{Integer types in C}
C has several related machine-dependent integer types:

\begin{description}
    \item[\texttt{size\_t}] Integer type appropriate to represent the
    size of any object, including indexing into at array.
    This is the most frequent use of \texttt{usize} in Rust.
    \item[\texttt{ptrdiff\_t}] Integer type large enough to store the
    difference between two addresses. In Rust, there is no motive to
    compare pointers from different allocations, so a \texttt{size\_t}
    equivalent suffices.
    \item[\texttt{intptr\_t}] Optional signed integer type large enough to hold
    a pointer. The commonly-understood definition of \texttt{isize} in Rust.
    \item[\texttt{uintptr\_t}] Optional unsigned integer type large enough to hold
    a pointer. The commonly-understood definition of \texttt{usize} in Rust.
\end{description}

What is important to see is that the specific integer value of a pointer
is of no intrinsic interest, and only matters in comparison to other
pointers.
Further, it is meaningless to compare pointers to different objects.
The Rust core library's principal use of the LLVM \texttt{inttoptr}
primitive is to determine the size of an allocation, which is consistent
with the above statements.

Most importantly, the key argument for only having one integer type that
corresponds to C's four was that Rust semantics are different, and the
require different reasoning and types.
This is precisely true: there is no functional use for non-address part
of a CHERI capability pointer, and the addressable range should
\emph{not} be conflated with the pointer size.


\section{Porting safe languages to capability architectures}
\label{sec:eval-porting}

This chapter has analysed how different mechanisms and protections of
the memory-safe Rust language interact with CHERI capabilities.
This section generalises many of its observations to other safe
languages, giving a preview of the relevant concerns when bringing other
languages and runtimes to hardware capability platforms.


\subsection{Weaknesses in language runtimes}
Many safe languages employ type systems to prevent unauthorised reading
or writing of data, but their runtimes can be a source of
vulnerabilities.
For example, a 2017 bug in CPython\footnote{The Python runtime.}
contained a bug potentially giving arbitrary code execution from a heap
overflow~\cite{cpython-overflow}.

\Cref{sec:eval-micro-repeat} showed a similar exploit prevented by CHERI
capabilities, and in the Python example, the heap allocation would not
successfully overflow with capabilities.
Note that CPython is written in a combination of C and Python, and this
routine in particular is written in C.
This shows how safe languages suffer vulnerabilities through their
runtimes.


\subsection{Unsafe code}
Continuing from the previous section, like Rust's \texttt{unsafe}, most
`safe' languages provide escape hatches: an example is Haskell's
\texttt{performUnsafeIO}.
Failing to do so limits the range of behaviour that programs in that
language can exhibit efficiently.
Similar mechanisms are used to call code written in other languages,
such as via the Java Native Interface (JNI).

Chisnall et al.\ have considered the application of CHERI capabilities
to JNI calls~\cite{cheri-jni}, and Watson et al.\ demonstrate
compartmentalisation alongside CHERI capabilities~\cite{cheri2015}.
In both cases, protections are applied to what is generally the only
significant attack surface of a program, making it an efficient design
choice.

Likewise, capability-aware languages could employ capability sealing to
guarantee that data is not inspected or modified when passing references
through system or cross-process calls, enforcing the principle of least
privilege.


\subsection{Language semantics and implementation}
Each language has a different memory model, which may not be fully
consistent with CHERI, which may prevent certain idioms from translating
properly.
C has a notoriously weak memory model, permitting pointer operations
which destroy provenance under CHERI, making them non-dereferenceable:
in particular, such patterns are used in real-world
programs~\cite{memarian2016cdepths}.

Nevertheless, when Davis et al.\ examine the issue for FreeBSD and
PostgreSQL, pointer provenance is not as significant an issue as one
might expect~\cite{cheri-2019-abstract}.
It is probable that any pointer provenance issues to do with safe
languages come from, as in Rust, the compiler and runtime rather than
general programs written in that language.


\subsection{Non-optimisation: type systems}
Languages may use type systems to make significant guarantees about
programs: this is especially true in functional languages.
Outside of these, Java and Rust have sophisticated type systems; the use
of capabilities cannot optimise checks that are made at compile time.

A contrasting example is Python, which performs type-checking at
runtime: this cannot be optimised by capabilities either, as more
information is derived from types in general.
Ultimately, it may be the case that capabilities are uniquely useful for
weakly-typed languages such as C.


\section{Summary}
\label{sec:eval-summary}

This chapter began by demonstrating how effectively CHERI capabilities
mitigate Rust vulnerabilities.
As further evidence of this point, another vulnerability in the Rust
standard library was announced while writing this
report~\cite{rust-advisory-cast}: it permitted arbitrary typecasting and
hence buffer overflows.
Again this is prevented by CHERI capabilities.

It detailed how Rust and CHERI memory protection mechanisms interact,
and choices that would maximise the benefit while minimising the cost.
This was done in light of Rust's semantics and definition of undefined
behaviour, identifying the weakest points in the language and showing
how they can be protected with capabilities.
Consideration was also given to implementation issues in the compiler,
resulting from under-defined semantics, and a strategy to tackle this
presented.
Finally, it generalised the impact of Rust capabilities to other
languages and runtimes, showing the areas which would benefit the most
and least from capability protection.

\end{document}
