\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Background and related work}
\label{ch:bg}


\clar{What is relevant? Most capability/fat pointer literature discusses
C, where I'm very much focussed on a `safe' language.}

\wip{rephrase} This chapter provides an overview of capabilities, CHERI,
and safe languages with capabilities.
Rust is discussed in \Cref{ch:rust}.


\section{Capabilities}
\label{sec:bg-caps}
Capabilities are traditionally known as unforgeable tokens of authority.
CHERI provides \emph{memory capabilities}: unforgeable pointers to
continuous regions in memory~\cite{cheri-risc-2014}.
\wip{``more on this in the next sections''}

Capabilities have a long history: while the concept had been established
beforehand, they were implemented and expounded in
Multics~\cite{bell-lapadula}, and there is recurring interest in fat
pointers today~\cite{devietti-hardbound,lowfat-kwon}.
They can prevent common classes of attacks, such as the
eternal buffer overflow (1,613 published CVEs in 2018
alone~\cite{nist-nvd-overflow-2018}), and obviate other mitigations,
such as address-space layout randomisation and W\^{}X protection
against execution of writeable data.

A recurring theme in this work is the definition and usage of pointers.
For instance, the proper usage of a capability renders object bounds
checks redundant: can this optimise bounds checks in Rust?
We will also see that CHERI's implementation of capability pointers
stretches a key language definition in Rust due to its usage in the
compiler.


\section{CHERI: Capability Hardware Enhanced RISC Instructions}

\subsection{Memory capability model}
\todo{rewrite}

CHERI extends the 64-bit MIPS ISA to support capabilities.
Its design emphasises incremental adoption, and the principles of least
privilege and intentional use, to mitigate unintended vulnerabilities.
Its hybrid approach enables capability code to be used alongside
non-capability code, allowing a concentration on higher-risk code and
libraries~\cite{cheri-v6}.

\subsection{Implementation overview}

\subsubsection{Capability coprocessor and registers}
A capability coprocessor is used to implement the CHERI extensions.
The coprocessor implements its own register file, creating a clear
distinction between integers and capabilities.
Instructions are added for manipulating these capability registers, such
as loads and stores, decreasing the bounds on capabilities, and
branching based on capability tags~\cite{cheri-risc-2014}.

\subsubsection{Memory tagging}
To support pointers to be stored anywhere in memory, an out-of-band tag
bit is associated with each (aligned) pointer-sized location in memory.
If a location storing a capability is written to be a non-capability
instruction, this bit is cleared to preserve the unforgeability of
pointers~\cite{cheri-risc-2014}.

\subsubsection{Capability manipulation}
CHERI provides capability instructions for using capabilities, from
those defining the bounds of a capability, to loading from and jumping
to a capability register.
Instructions conform to the property of \emph{monotonicity}: they can
only decrease privilege, so to preserve
unforgeability~\cite{cheri-risc-2014}.
Thus capability bounds (length) cannot be increased, nor can a read-only
capability derive a read-write one.


\subsection{Using non-capability code}
Code that is not capability-aware is interoperable with capability code,
through instructions that translate between capabilities and integer
pointers.
The latter are protected by the \emph{implicit capability register},
\textbf{C0}.
This allows protection of non-capability code from capability-aware code
and vice versa~\cite{cheri-risc-2014}.
The contemporaneous usage of regular pointers and capabilities is known
as \emph{hybrid mode}, whereas a program that exclusively used
capabilities is deemed to run in \emph{pure capability
mode}~\cite{cheri-prog-guide}.

This project evaluates Rust under pure capability mode only.
The choice has proven to be a practical one: in keeping consistent with
LLVM's memory model, the Rust compiler avoids pitfalls that lead to
capability incompatibility.


\section{Why Rust?}
\label{sec:bg-why-rust}

Most evaluations of capability implementations focus on the C language,
as a kind of lowest common denominator in computer systems.
Further, its stereotypical memory unsafety precedes a reasonable
assumption that C programs would benefit from capabilities, perhaps more
so than a safe language would.

Rust is such an example of a safe language.
The following sections briefly motivate the choice of Rust as a language
on which to evaluate a capability platform;
see \Cref{ch:rust} for an overview of language features and semantics
relevant to the use of capabilities.

Finally, it provides a foil to C evaluations of capabilities, in both
adoption and utility of capabilities.


\subsection{Bounds checks in Rust}
\label{sec:bg-rust-bounds}

\begin{figure}[ht]
    \lstinputlisting[language={[mips64]Assembler}]{listings/array-deref.s}
    \caption{
        Generated MIPS64 assembler for Rust's intrinsic indexing on
        arrays and vectors, with bounds checks.
        The relevant \emph{unchecked} access is only lines~7--9.
        Rust instructs LLVM that the out-of-bounds case is unlikely,
        but this does not appear in the generated code.
        Comments added for ease of reading;
        \texttt{panic\_bounds\_check} string substituted in place of
        mangled version.
    }
    \label{lst:bg-rust-index}
\end{figure}

One of Rust's safety features is runtime bounds checks on array
accesses: \Cref{lst:bg-rust-index} shows an example.
As arrays have clear bounds, these checks also occur when dereferencing
a CHERI capability.
If object bounds are set correctly, the runtime checks are redundant and
could be removed as an optimisation.


\subsection{Broad similarity to C}
While Rust espouses very different design principles to C, it targets
similar applications, such as systems programming.
It emphasises a small runtime, and its compilation and linking process
is similar, as opposed to interpreted or JIT compiled languages.
An evaluation using Rust is more immediately relevant and readily
comprehensible in the context of existing literature, and applicable in
re-interpreting it.

Additionally, it is trivial to link against C libraries, so a smaller
proportion of the Rust standard libraries need be considered for a
meaningful evaluation (\Cref{sec:impl-what}).


\subsection{Object lifetimes and temporal safety}
Rust uses \emph{object lifetimes} instead of placing the burden on users
to manage memory, or using a garbage collector.
Like manual memory management, this design enforces intentionality, but
is enforced by the compiler to prevent dangling pointers and
use-after-free unsafety.
This is a major feature preventing temporal unsafety, an area for which
capabilities have no universal remedy, unlike the spatial integrity they
frequently provide.
As such, Rust has a built-in mechanism complementary to that provided by
capabilities, and the interaction between these is worth examination.


\section{Survey of related work}
\label{sec:bg-related}

\wip{Overview}
Primarily examining safe languages and capabilities: there has been a
lot of work on C and capabilities.

\clar{Seems everybody stops short of actually implementing Java on a
capability platform.}

CHERI in C.
Fat pointers/capabilities in C.
Capabilities on any other safe language?

\clar{How much subtlety is required in the following sections? At
present, none is attempted.}

\todo{Caja: capabilities for a subset of javascript. `Object
Capabilities and Isolation of Untrusted Web Applications', 2010.
No discussion of optimisation, but relevant to the Rust angle.}

\todo{J-Kernel: 1999, isolation of web applications (server-side).
Little discussion of overheads (``small''), or hardware; left to future
work.}


\subsection{Hardbound}
\label{sec:rel-hardbound}

Hardbound provides special instructions to set bounds on pointers,
preventing out-of-bounds dereferences~\cite{devietti-hardbound}.
Like CHERI, it has no mechanism to handle use-after-free or double-free
errors, only identifying invalid dereferences.

It emphasises minimal compiler and memory layout changes, making it
theoretically adaptable to many different compilers, including compilers
to safe languages such as Rust.

Woodruff et al.~\cite{cheri-risc-2014} detail differences between
Hardbound and CHERI; for the purposes of this work, much of the
evaluation applies equally or similarly to Hardbound.
Notable exceptions would include pointer width compatibility,\footnote{
Hardbound is capable of compressing (less) pointer information, avoiding
changing the pointer width.
} the comments on enforcing immutability, and protecting against abuse
through FFI functions.


\subsection{AddressSanitizer}
\label{sec:rel-asan}

AddressSanitizer maintains shadow state to find memory errors, including
bounds checks but also use-after-free errors, with a limited possibility
of detecting data races~\cite{serebryany-asan}.
As it does not implement object boundaries on pointers, a correctly
chosen offset could result in an out-of-bounds dereference into another
object.

It is implemented using LLVM infrastructure, and the primary use target
is C code via Clang.
There is experimental support for compiling Rust with AddressSanitizer
support, as well as the related LeakSanitizer, MemorySanitizer, and
ThreadSanitizer~\cite{rust-san}.
While it is not expected to be useful for Safe Rust code, the main
incentives for the Rust project appear to be supporting fuzz testing,
finding compiler bugs, and checking unsafe code~\cite{rust-asan-track}.

As such, it targets a subset of problems in Rust as CHERI capabilities
do, albeit in software.
While the authors suggest that AddressSanitizer could be run in
production code, it suffers a considerable \(2\times\) slowdown.


\subsection{Sandcrust: Sandboxing Rust's FFI}
\label{sec:rel-sandcrust}

Sandcrust is a set of macros and Rust compiler transformations which aim
to sandbox and transform C functions called from
Rust~\cite{lamowski-sandcrust}.
Its primary means of achieving isolation is to execute library code in a
separate process from Rust caller, communicating via remote procedure
calls (RPC) and pipes.
This avoids giving libraries access to memory which should not be
shared, and frustrates attacks such as control-flow hijacking.

This approach comes with considerable overhead, with Lamowski et al.\
reporting slowdown factors between 1.3 and 44, albeit generally at the
low end (1.5--\(8\times\)).
Considerable overhead is likely due to data transfer.

CHERI avoids this overhead, and can call foreign functions in the same
address space as the Rust program.
Interestingly, such a sandboxing scheme could protect data which is only
required for callback functions, similarly to capability sealing in
\Cref{sec:eval-rust-xprocess}.\footnote{
    However, a pointer passed to an external library could be modified
    to point to a different object, which is not possible with a sealed
    capability.
}
I do not discuss Sandcrust's ancillary functionality of wrapping C
functions to fit Rust idioms which has value of its own.


\subsection{Robusta: Sandboxing JNI code}
The Java Native Interface (JNI) provides full access to the address
space of a Java program, and JNI code is completely trusted by Java's
security model.
Robusta sandboxes native calls by intercepting calls to native
functions, building on Google's Native Client.
It also executes native code in a separate process, again copying data
as necessary.
System calls pass through JVM permissions checks, extending the Java
security manager to native code~\cite{siefers-robusta}: in essence, a
reference monitor in the JVM.

Native Client provides separation for the primary purpose of
computation, reporting around 5\% overhead for computational
tasks~\cite{yee-nacl}; Siefers et al.\ give similar figures for
computational tasks on Robusta.
Conceivably, such a small overhead could also apply to sandboxing in
Rust, on the same tasks and with some optimisation.
However, with less computational tasks, copying objects in and out of
the sandbox can lead to over \(15\times\) slowdown.

Note again that Robusta does more than improve memory safety: it also
intercepts system calls to ensure they are permitted by the Java
security manager.


\subsection{CHERI compartmentalisation and the JNI}
\label{sec:rel-cheri-jni}

As an alternative to process-based sandboxing, CheriBSD provides
compartmentalisation for cross-domain calls (cross-process and system
calls).
Watson et al.\ show that compartmentalisation with CHERI capabilities
vastly outperforms process-based approaches, as the data flow overhead
is non-existent.
Compartmentalisation can also be used to restrict and protect system
calls, such as only allowing certain system calls or preventing
tampering with file descriptors~\cite{cheri2015}.

Chisnall et al.\ use compartmentalisation to sandbox JNI code, eliminating
data flow and domain crossing overheads, and enabling sealing
(\Cref{sec:eval-rust-xprocess} discusses this in a Rust context), among
other benefits~\cite{cheri-jni}.
Like Robusta, this includes Java security manager checks on native code.
They include a detailed comparison of compartmentalisation to
process-based sandboxing.


\subsection{Efforts to reduce undefined behaviour in Rust}
Alone, general adherence to safety principles cannot guarantee a lack of
undefined behaviour or vulnerabilities.
Other efforts are under way to check for and reduce undefined behaviour,
especially in the compiler and standard library:

Ralf Jung: RustBelt.


\end{document}
