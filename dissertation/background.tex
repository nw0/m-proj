\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Background and related work}
\label{ch:bg}


\clar{What is relevant? Most capability/fat pointer literature discusses
C, where I'm very much focussed on a `safe' language.}

\wip{rephrase} This chapter provides an overview of capabilities, CHERI,
and safe languages with capabilities.
Rust is discussed in \Cref{ch:rust}.


\section{Capabilities}
A \emph{capability} is the address of an entity combined with the
permitted actions using that reference~\cite{Dennis:1966:PSM}.
An entity may traditionally be a memory segment, and actions could be to
write or execute that segment.
Throughout this work, a recurring theme will be the arbitrary
dereferencing of pointers, an action permitted in Unsafe Rust, but not
Safe Rust.

Capabilities have a long history: while the concept had been established
beforehand, they were implemented and expounded in
Multics~\cite{bell-lapadula}, and there is recurring interest in fat
pointers today~\cite{hardbound-devietti,lowfat-kwon}.
They can prevent common classes of attacks, such as the
eternal buffer overflow (1,613 published CVEs in 2018
alone~\cite{nist-nvd-overflow-2018}), and obviate other mitigations,
such as address-space layout randomisation and W\^{}X protection
against execution of writeable data.


\section{CHERI: Capability Hardware Enhanced RISC Instructions}
CHERI extends a 64-bit RISC ISA to support capabilities.
Its design emphasises incremental adoption, and the principles of least
privilege and intentional use, to mitigate unintended vulnerabilities.
Its hybrid approach enables capability code to be used alongside
non-capability code, allowing a concentration on higher-risk code and
libraries~\cite{cheri-v6}.


\section{Why Rust?}
\label{sec:bg-why-rust}

\clar{Its reputation as a safe systems language? Bounds checks? Easier
than Java? Commitment to security? Probably because it's `similar' to
C---this aids comparisons. Also, it has no GC, and lifetimes are
interesting and helpful, related to revocation.}

\subsection{Bounds checks in Rust}

\begin{figure}[ht]
    \lstinputlisting[language={[mips]Assembler}]{listings/array-deref.s}
    \caption{
        Generated MIPS64 assembler for Rust's intrinsic indexing on
        arrays and vectors, with bounds checks.
        The relevant \emph{unchecked} access is only lines~7--9.
        Comments added for ease of reading;
        \texttt{panic\_bounds\_check} string substituted in place of
        mangled version.
    }
    \label{lst:bg-rust-index}
\end{figure}


\section{Survey of related work}
\label{sec:bg-related}

\wip{Overview}
Primarily examining safe languages and capabilities: there has been a
lot of work on C and capabilities.

\clar{Seems everybody stops short of actually implementing Java on a
capability platform.}

CHERI in C.
Fat pointers/capabilities in C.
Capabilities on any other safe language?

\clar{How much subtlety is required in the following sections? At
present, none is attempted.}

\todo{Hardbound? This would be a nice contrast to CHERI, but isn't
strongly related. Can I spare the wordcount?}

\todo{Caja: capabilities for a subset of javascript. `Object
Capabilities and Isolation of Untrusted Web Applications', 2010.
No discussion of optimisation, but relevant to the Rust angle.}

\todo{J-Kernel: 1999, isolation of web applications (server-side).
Little discussion of overheads (``small''), or hardware; left to future
work.}

\todo{Peaks: capability model for Java. Primarily JNI, but ostensibly
geared for library use which may not include JNI.
\url{http://www.thewhitespace.de/projects/peaks/}}

\todo{ASAN/HWASAN: CHERI does detect overflows, but not uninitialised
accesses.}

\subsection{CHERI and the Java Native Interface}
\label{sec:bg-cheri-jni}

Capabilities are a viable alternative to sandboxing JNI
functions~\cite{cheri-jni}.
Chisnall et al.~proposes safe direct access to buffers owned by the JVM,
rather than copying, and without exposing the rest of the JVM's memory.
This preserves Java safety guarantees.


\subsection{Efforts to reduce undefined behaviour in Rust}
Alone, general adherence to safety principles cannot guarantee a lack of
undefined behaviour or vulnerabilities.
Other efforts are under way to check for and reduce undefined behaviour,
especially in the compiler and standard library:

Lamowski: Sandcrust.
Ralf Jung: RustBelt.


\end{document}
