\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Background and related work}
\label{ch:bg}


\clar{What is relevant? Most capability/fat pointer literature discusses
C, where I'm very much focussed on a `safe' language.}

\wip{rephrase} This chapter provides an overview of capabilities, CHERI,
and safe languages with capabilities.
Rust is discussed in \Cref{ch:rust}.


\section{Capabilities}
\label{sec:bg-caps}
Capabilities are traditionally known as unforgeable tokens of authority.
CHERI provides \emph{memory capabilities}: unforgeable pointers to
continuous regions in memory~\cite{cheri-risc-2014}.
\wip{``more on this in the next sections''}

Capabilities have a long history: while the concept had been established
beforehand, they were implemented and expounded in
Multics~\cite{bell-lapadula}, and there is recurring interest in fat
pointers today~\cite{devietti-hardbound,lowfat-kwon}.
They can prevent common classes of attacks, such as the
eternal buffer overflow (1,613 published CVEs in 2018
alone~\cite{nist-nvd-overflow-2018}), and obviate other mitigations,
such as address-space layout randomisation and W\^{}X protection
against execution of writeable data.

A recurring theme in this work is the definition and usage of pointers.
For instance, the proper usage of a capability renders object bounds
checks redundant: can this optimise bounds checks in Rust?
We will also see that CHERI's implementation of capability pointers
stretches a key language definition in Rust due to its usage in the
compiler.


\section{CHERI: Capability Hardware Enhanced RISC Instructions}

\subsection{Memory capability model}
\todo{rewrite}

CHERI extends the 64-bit MIPS ISA to support capabilities.
Its design emphasises incremental adoption, and the principles of least
privilege and intentional use, to mitigate unintended vulnerabilities.
Its hybrid approach enables capability code to be used alongside
non-capability code, allowing a concentration on higher-risk code and
libraries~\cite{cheri-v6}.

\subsection{Implementation overview}

\subsubsection{Capability coprocessor and registers}
A capability coprocessor is used to implement the CHERI extensions.
The coprocessor implements its own register file, creating a clear
distinction between integers and capabilities.
Instructions are added for manipulating these capability registers, such
as loads and stores, decreasing the bounds on capabilities, and
branching based on capability tags~\cite{cheri-risc-2014}.

\subsubsection{Memory tagging}
To support pointers to be stored anywhere in memory, an out-of-band tag
bit is associated with each (aligned) pointer-sized location in memory.
If a location storing a capability is written to be a non-capability
instruction, this bit is cleared to preserve the unforgeability of
pointers~\cite{cheri-risc-2014}.

\subsubsection{Capability manipulation}
CHERI provides capability instructions for using capabilities, from
those defining the bounds of a capability, to loading from and jumping
to a capability register.
Instructions conform to the property of \emph{monotonicity}: they can
only decrease privilege, so to preserve
unforgeability~\cite{cheri-risc-2014}.
Thus capability bounds (length) cannot be increased, nor can a read-only
capability derive a read-write one.


\subsection{Using non-capability code}
Code that is not capability-aware is interoperable with capability code,
through instructions that translate between capabilities and integer
pointers.
The latter are protected by the \emph{implicit capability register},
\textbf{C0}.
This allows protection of non-capability code from capability-aware code
and vice versa~\cite{cheri-risc-2014}.
The contemporaneous usage of regular pointers and capabilities is known
as \emph{hybrid mode}, whereas a program that exclusively used
capabilities is deemed to run in \emph{pure capability
mode}~\cite{cheri-prog-guide}.

This project evaluates Rust under pure capability mode only.
The choice has proven to be a practical one: in keeping consistent with
LLVM's memory model, the Rust compiler avoids pitfalls that lead to
capability incompatibility.


\section{Why Rust?}
\label{sec:bg-why-rust}

Most evaluations of capability implementations focus on the C language,
as a kind of lowest common denominator in computer systems.
Further, its stereotypical memory unsafety precedes a reasonable
assumption that C programs would benefit from capabilities, perhaps more
so than a safe language would.
\wip{ref jni-cheri,peaks}

Rust is such an example of a safe language.
The following sections briefly motivate the choice of Rust as a language
on which to evaluate a capability platform;
see \Cref{ch:rust} for an overview of language features and semantics
relevant to the use of capabilities.

Finally, it provides a foil to C evaluations of capabilities, in both
adoption and utility of capabilities.


\subsection{Bounds checks in Rust}
\label{sec:bg-rust-bounds}

\begin{figure}[ht]
    \lstinputlisting[language={[mips64]Assembler}]{listings/array-deref.s}
    \caption{
        Generated MIPS64 assembler for Rust's intrinsic indexing on
        arrays and vectors, with bounds checks.
        The relevant \emph{unchecked} access is only lines~7--9.
        Rust instructs LLVM that the out-of-bounds case is unlikely,
        but this does not appear in the generated code.
        Comments added for ease of reading;
        \texttt{panic\_bounds\_check} string substituted in place of
        mangled version.
    }
    \label{lst:bg-rust-index}
\end{figure}


\subsection{Clean FFI abstraction}

\subsection{Broad similarity to C}

\subsection{Object lifetimes and temporal safety}


\section{Survey of related work}
\label{sec:bg-related}

\wip{Overview}
Primarily examining safe languages and capabilities: there has been a
lot of work on C and capabilities.

\clar{Seems everybody stops short of actually implementing Java on a
capability platform.}

CHERI in C.
Fat pointers/capabilities in C.
Capabilities on any other safe language?

\clar{How much subtlety is required in the following sections? At
present, none is attempted.}

\todo{Caja: capabilities for a subset of javascript. `Object
Capabilities and Isolation of Untrusted Web Applications', 2010.
No discussion of optimisation, but relevant to the Rust angle.}

\todo{J-Kernel: 1999, isolation of web applications (server-side).
Little discussion of overheads (``small''), or hardware; left to future
work.}

\todo{Peaks: capability model for Java. Primarily JNI, but ostensibly
geared for library use which may not include JNI.
\url{http://www.thewhitespace.de/projects/peaks/}}


\subsection{Hardbound}
\label{sec:rel-hardbound}

Hardbound provides special instructions to set bounds on pointers,
preventing out-of-bounds dereferences~\cite{devietti-hardbound}.
Like CHERI, it has no mechanism to handle use-after-free or double-free
errors, only identifying invalid dereferences.

It emphasises minimal compiler and memory layout changes, making it
theoretically adaptable to many different compilers, including compilers
to safe languages such as Rust.

\todo{Precisely why this is different to CHERI (wrt Rust)}


\subsection{AddressSanitizer}
\label{sec:rel-asan}

AddressSanitizer maintains shadow state to find memory errors, including
bounds checks but also use-after-free errors, with a limited possibility
of detecting data races~\cite{serebryany-asan}.
As it does not implement object boundaries on pointers, a correctly
chosen offset could result in an out-of-bounds dereference into another
object.
\todo{Why do we care about asan}

It is implemented using LLVM infrastructure, and the primary use target
is C code via Clang.
There is experimental support for compiling Rust with AddressSanitizer
support, as well as the related LeakSanitizer, MemorySanitizer, and
ThreadSanitizer~\cite{rust-san}.
While it is not expected to be useful for Safe Rust code, the main
incentives for the Rust project appear to be supporting fuzz testing,
finding compiler bugs, and checking unsafe code~\cite{rust-asan-track}.


\subsection{CHERI and the Java Native Interface}
\label{sec:bg-cheri-jni}

Capabilities are a viable alternative to sandboxing JNI
functions~\cite{cheri-jni}.
Chisnall et al.\ propose safe direct access to buffers owned by the JVM,
rather than copying, and without exposing the rest of the JVM's memory.
This preserves Java safety guarantees.


\subsection{Sandcrust: Sandboxing Rust's FFI}
\label{sec:rel-sandcrust}

Sandcrust is a set of macros and Rust compiler transformations which aim
to sandbox and transform C functions called from
Rust~\cite{lamowski-sandcrust}.
Its primary means of achieving isolation is to execute library code in a
separate process from Rust caller, communicating via remote procedure
calls (RPC) and pipes.
This avoids giving libraries access to memory which should not be
shared, and frustrates attacks such as control-flow hijacking.

This approach comes with considerable overhead, with Lamowski et al.\
reporting slowdown factors between 1.3 and 44, albeit generally at the
low end (1.5--\(8\times\)).
Considerable overhead is likely due to data transfer.

CHERI avoids this overhead, and would call foreign functions in the same
address space as the Rust program.
Interestingly, such a sandboxing scheme could protect data which is only
required for callback functions, similarly to capability sealing in
\Cref{sec:eval-rust-xprocess}.\footnote{
    However, a pointer passed to an external library could be modified
    to point to a different object, which is not possible with a sealed
    capability.
}
I do not discuss Sandcrust's ancillary functionality of wrapping C
functions to fit Rust idioms which has value of its own.


\subsection{Efforts to reduce undefined behaviour in Rust}
Alone, general adherence to safety principles cannot guarantee a lack of
undefined behaviour or vulnerabilities.
Other efforts are under way to check for and reduce undefined behaviour,
especially in the compiler and standard library:

Ralf Jung: RustBelt.


\end{document}
