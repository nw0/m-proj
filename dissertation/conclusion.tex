\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Conclusion}

\section{Context and review}

This project examined protection mechanisms to provide memory safety at
the intersection of hardware and computer architecture, compilers, and
programming language semantics.
The varied approaches and measures shed light on the subtlety of
two orthogonal problems: spatial and temporal integrity.
These insights illustrate different ways of enforcing the principles of
\emph{least privilege} and \emph{intentional use}, and the compromises
and difficulties that arise from their interaction.

\todo{Comments on the work. What was special or challenging?}

Even as CHERI begins to form a foundation for its own temporal memory
protection, the study of how the architecture interacts with memory-safe
languages forms a basis for realising its potential in the larger
ecosystem of modern software development.


\section{Scope of contributions}

This project was principally concerned with the challenges that arise
from bringing a safe language to the CHERI architecture, and how they
interact with each other.
In providing an account of these concerns, it made a number of
contributions:

\clar{I omit the first bulleted contribution from the introduction, to
do with the background and related work chapters.

I am planning to delete said point from that section. Should I do so?}

\begin{itemize}
    \item Patches to the Rust compiler and core libraries enabling
    support for CHERI capabilities, without compiler optimisations.
    Details of the necessary further work to fully support a CHERI
    target, including the language design choices which pose problems
    for this task.
    These modifications formed the basis on which I evaluated Rust on
    CHERI.

    \item Verification that the modified compiler produces programs
    which use capabilities, by demonstrating capability protection
    against previous vulnerabilities.
    Analyses of these and other vulnerabilities, which were all present
    in the Rust core library, showing that capabilities are effective in
    fully mitigating the errors.

    \item An evaluation of the interactions between Rust and CHERI
    protection mechanisms, focussed on how the two complement each
    other to provide stronger memory safety guarantees.
    I elucidated how CHERI provisions such as \emph{capability sealing}
    bring new memory safety properties to Rust, especially the means
    to enforce previously-unenforceable invariants on which Rust
    predicates its memory safety guarantees.

    \item The evaluation further investigated approaches that reduce the
    overheads posed by these memory protection mechanisms without
    reducing memory safety.
    It proposed configurations that avoid unnecessary duplication of
    strong protections, but instead work to reinforce the most
    vulnerable points of Rust programs: the use of unsafe code and
    cross-domain calls.
    Further, I highlighted the trade-offs of different combinations of
    protection techniques and how they affect memory safety, crucial
    factors for implementers bringing Rust to CHERI.

    \item I addressed details of the Rust language and implementation
    that currently prevent full Rust compatibility with CHERI.
    Of specific interest is the definition of \texttt{usize} in the
    language, changes to which would need to be put to the Rust
    community.
    Also discussed is how different aspects of protection and
    implementation might apply to other safe languages and their
    runtimes, providing insight into CHERI's implications for the wider
    software development ecosystem.
\end{itemize}

\section{Further work}

\subsection{Clarify Rust's provenance model}

\subsection{Pointer-width sized indices}

\subsubsection{Changes to Rust semantics}
\Cref{sec:eval-usize} considered Rust's \texttt{usize} definition, which
is ``pointer-sized integer'', why this is not desirable, and explored
alternatives.
As this is both a semantic and performance issue on CHERI
(\Cref{sec:impl-width}), it should be a priority to resolve this
definition sooner rather than later.

Nevertheless, this is not a straightforward task.
A unilateral change would involve large divergences from the upstream
code, as the pointer width and index sizes are implicitly used
interchangeably in the Rust compiler.
Since such a change affects the Rust semantics, and potentially
introduces new types, it inevitably will have to be proposed via the
Rust RFC system.
The issue has been discussed before~\cite{rust-rfc-isize,rust-int-uint};
I suggest that the least controversial change would be to reinterpret
the current rule and leave the introduction of any new types for a later
effort.
This could take a significant amount of time and human effort to effect,
and is entirely beyond the scope of this exploratory work.

\subsubsection{Implementation in the compiler}
This change could then be implemented in the compiler.
As noted above, this would be challenging to do without first achieving
consensus on the semantics.

While there are numerous references that do not fully distinguish
between pointer size and index size, the CTSRD project has experience
resolving similar issues in Clang and LLVM, showing that the problem is
not insurmountable.

\subsection{Runtime and memory overhead analysis}
\todo{Can use miri to count pointers in the heap? Hence do memory analysis}

\subsection{Fine-grained capability protection}

\end{document}
