\documentclass[dissertation.tex]{subfiles}
\begin{document}

\chapter{Introduction}
\label{ch:intro}

\section{Motivation}
\label{sec:intro-motiv}

\wip{This is chopped up from the proposal}
\subsection{Background}
Many security vulnerabilities are bugs arising from the lack of memory safety in C; an example of a traditional exploit is the buffer overflow.
The C language specification includes a number of situations that lead to \emph{undefined behaviour}: akin to a deduction of `falsity' in logic, after these points the state of the program might be arbitrary.
Undefined behaviour allows compilers to assume that certain conditions never hold, enabling them to make powerful (but dangerous) optimisations.

Consequently, crucial checks can be optimised away and invariants violated by compilers, resulting in executables vulnerable to memory attacks~\cite{simon2018wygiwyc}.
Many systems and compiler programmers frequently underestimate the pervasiveness of undefined behaviour in code that appears to function correctly, and gloss over the subtleties of the C standard~\cite{memarian2016cdepths};
these represent future opportunities for vulnerabilities to arise when code is optimised away by compiler transformations~\cite{wang2013towards}.

\todo{Talk about spatial and temporal safety +new points from evaluation}


\subsection{The Rust programming language}

\wip{citations?}

Rust is billed as a fast, safe language designed for concurrent systems
programming.
Safe Rust claims to offer type- and memory-safety, and guarantees not to
encounter dangling pointers or any undefined
behaviour~\cite{rust-nomicon-safe-unsafe}.

To achieve this, it uses compile-time and runtime checks, relying on a
combination of LLVM optimisations and \emph{Unsafe} Rust code to
minimise the performance overhead.
However, as with all code that requires fine control over memory,
mistakes in writing Unsafe Rust give rise to potential vulnerabilities.

\subsubsection{Vulnerabilities in Rust}
There have been a number of bugs and potential vulnerabilities in Rust,
none of which are believed to be exploited.
Some of these were exposed but potentially preventable with CHERI
capabilities (discussed in \Cref{sec:eval-bugs}):

\begin{itemize}
    \item Standard library: buffer overflow when pushing to a
    \texttt{VecDeque}, CVE-2018-1000657~\cite{cve-push,rust-issue-push}.
    \item Standard library: buffer overflow in slice \texttt{repeat},
    CVE-2018-1000810~\cite{cve-repeat,rust-advisory-repeat,rust-pr-slice}.
    \item Standard library: out-of-bounds access indexing into a
    reversed slice~\cite{rust-pr-reverse,rust-commit-reverse}.
    \wip{section?}
    \item Standard library: unsafe \texttt{Vec} method creates
    multiple mutable references, violating temporal
    safety *catchable with sealing~\cite{rust-issue-vec-mut}.
    \wip{section?}
    \item Compiler bug: uncaught move of an implicitly-borrowed
    immutable value *sealing~\cite{rust-issue-match-borrow}.
    \wip{section?}
\end{itemize}

Others are not mitigated by capabilities:

\begin{itemize}
    \item Standard library: attempt to read uninitialised memory after
    appending to a \texttt{VecDeque}~\cite{rust-issue-deque-append}.
    \item Compiler plugin: documentation plugin allowed arbitrary code
    execution by a different user while running the
    compiler, CVE-2018-1000622~\cite{cve-rustdoc,rust-advisory-rustdoc}.
\end{itemize}

Collectively, these show that even with a language designed for safety,
and in a safety-conscious developer community, it is still difficult to
avoid bugs that lead to unsoundness and possible vulnerabilities.
Therefore, more tools are needed to build and operate reliable and
secure software.


\subsection{Capabilities and the CHERI architecture}
The CHERI project provides \emph{capabilities}, which stops unauthorised access or modification of data by erroneous and malicious code~\cite{cheri-v6}.
In the CHERI architecture, capabilities restrict usage by associating bounds and access permissions with address data while making these unforgeable, as they can only be manipulated by the hardware.
This prevents abuse of pointers and internal addresses.

Just as using capabilities in C programs can prevent unintended operations on memory, applying capabilities to unsafe Rust code would provide an additional layer of safety, guarding against undiscovered vulnerabilities and potentially shrinking the set of unsafe operations.


\section{Contributions}
\label{sec:intro-contrib}

The main objective of this project was to evaluate the utility of
porting Rust to CHERI.
In summary, the contributions of this work are:

\todo{Rewrite, rephrase, and reorder these points.}

\begin{itemize}
    \item A survey of work relating to safe languages and capability
    platforms, and efforts to manage undefined behaviour and safety in
    programming languages.
    \item An evaluation of the benefits and detriments porting a safe
    language to CHERI, and capability architectures in general.
    This covers the benefits for the language, the architecture, and how
    a language may be enriched by capabilities.
    \item A summary of features and techniques Rust uses to provide
    memory safety guarantees, and how it optimises these.
    The differences between Rust and other languages, as they pertain to
    capability architectures and CHERI.
    Microbenchmarks demonstrating two potential vulnerabilities in
    the Rust standard library, functional on x86 but prevented by CHERI.
    \item Patches to the Rust compiler (1.35), providing
    \texttt{cheri-unknown-freebsd} (CHERI128) as a working target.
    This compiles the Rust core library without optimisations.
    \item An overview of the relevant concerns for future implementers
    porting Rust to CHERI.
\end{itemize}

This work is \emph{not} intended to port Rust to CHERI.
Rather, it illustrates the benefit of CHERI capabilities to a safe
language, rather than providing a full implementation.

\end{document}
