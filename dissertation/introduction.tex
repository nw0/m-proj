\documentclass[dissertation.tex]{subfile}

\chapter{Introduction}
\label{ch:intro}

\section{Motivation}
\label{sec:intro-motiv}

\wip{This is chopped up from the proposal}
\subsection{Background}
Many security vulnerabilities are bugs arising from the lack of memory safety in C; an example of a traditional exploit is the buffer overflow.
The C language specification includes a number of situations that lead to \emph{undefined behaviour}: akin to a deduction of `falsity' in logic, after these points the state of the program might be arbitrary.
Undefined behaviour allows compilers to assume that certain conditions never hold, enabling them to make powerful (but dangerous) optimisations.

Consequently, crucial checks can be optimised away and invariants violated by compilers, resulting in executables vulnerable to memory attacks~\cite{simon2018wygiwyc}.
Many systems and compiler programmers frequently underestimate the pervasiveness of undefined behaviour in code that appears to function correctly, and gloss over the subtleties of the C standard~\cite{memarian2016cdepths};
these represent future opportunities for vulnerabilities to arise when code is optimised away by compiler transformations~\cite{wang2013towards}.


\subsection{The Rust programming language}

\wip{citations?}

Rust is billed as a fast, safe language designed for concurrent systems
programming.
Safe Rust claims to offer type- and memory-safety, and guarantees not to
encounter dangling pointers or any undefined
behaviour~\cite{rust-nomicon-safe-unsafe}.

To achieve this, it uses compile-time and runtime checks, relying on a
combination of LLVM optimisations and \emph{Unsafe} Rust code to
minimise the performance overhead.
However, as with all code that requires fine control over memory,
mistakes in writing Unsafe Rust give rise to potential vulnerabilities.

\subsubsection{Vulnerabilities in Rust}
There have been a number of potentially exploitable vulnerabilities in
Rust, including:

\begin{itemize}
    \item Standard library: buffer overflow when pushing to a
    \texttt{VecDeque}, CVE-2018-1000657~\cite{cve-push,rust-issue-push}.
    \item Standard library: buffer overflow in slice \texttt{repeat},
    CVE-2018-1000810~\cite{cve-repeat,rust-advisory-repeat}.
    \\ \url{https://github.com/rust-lang/rust/pull/54399}
    \\ Hints \url{https://github.com/rust-lang/rust/issues/15482}
    \item The \texttt{rustdoc} CVE. Arbitrary code execution on host?
    \item Miscellaneous UB, e.g.~\url{https://github.com/rust-lang/rust/issues/53566}
    \item Jemalloc bug \url{https://github.com/rust-lang/rust/issues/15123}
    \item In general, violating no shared mut
    \url{https://github.com/rust-lang/rust/issues/39465}
    \item Interesting mutation in match arm -- not in scope
    \url{https://github.com/rust-lang/rust/issues/27282}
    \item Overflows have caught bugs
    \url{https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/}
\end{itemize}

\subsubsection{Efforts to reduce undefined behaviour}
Alone, general adherence to safety principles cannot guarantee a lack of
undefined behaviour or vulnerabilities.
Other efforts are under way to check for and reduce undefined behaviour,
especially in the compiler and standard library:

Lamowski: Sandcrust.
Ralf Jung: RustBelt.

\wip{Listing from proposal?}

\wip{List Rust guarantees? Mention the unsafe conditions?}


\subsection{Capabilities and the CHERI architecture}
The CHERI project provides \emph{capabilities}, which stops unauthorised access or modification of data by erroneous and malicious code~\cite{cheri-v6}.
In the CHERI architecture, capabilities restrict usage by associating bounds and access permissions with address data while making these unforgeable, as they can only be manipulated by the hardware.
This prevents abuse of pointers and internal addresses.

Just as using capabilities in C programs can prevent unintended operations on memory, applying capabilities to unsafe Rust code would provide an additional layer of safety, guarding against undiscovered vulnerabilities and potentially shrinking the set of unsafe operations.


\section{Intended contributions}
\label{sec:intro-contrib}

\begin{itemize}
    \item Patches to the Rust compiler (1.35) with
    \texttt{cheri-unknown-freebsd} (CHERI128) as a (limited) working
    target.
    \item Microbenchmarks demonstrating two potential vulnerabilities in
    the Rust standard library, functional on x86 but prevented by CHERI.
    \item Microbenchmarks of potential exploits prevented by \emph{both}
    capabilities and existing runtime checks. These demonstrate the
    viability and benefit of replacing checks with capabilities. Note
    that unwind panics may not be allowed.
\end{itemize}

This work is \emph{not} intended to port Rust to CHERI.
Rather, it illustrates and quantifies the benefit of CHERI capabilities
to a safe language, rather than a full implementation of such.
See proposal.
